import{a as Wr}from"./BR2YNKDZ.js";import{a as zr}from"./BIAB2ZEP.js";import{e as Zn}from"./O5NYTI7P.js";var H=Zn(zr()),mo=Zn(Wr());function Gr(e){let t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Hr=Gr,U=Hr;function Kr(e){return!!e&&typeof e.then=="function"}var Z=Kr;function qr(e,t){if(e!=null)return e;throw U(t??"Got unexpected null or undefined")}var Y=qr;function I(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var Fe=class{getValue(){throw U("BaseLoadable")}toPromise(){throw U("BaseLoadable")}valueMaybe(){throw U("BaseLoadable")}valueOrThrow(){throw U(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw U("BaseLoadable")}promiseOrThrow(){throw U(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw U("BaseLoadable")}errorOrThrow(){throw U(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw U("BaseLoadable")}},fn=class extends Fe{constructor(t){super(),I(this,"state","hasValue"),I(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{let n=t(this.contents);return Z(n)?Ve(n):ze(n)?n:lt(n)}catch(n){return Z(n)?Ve(n.next(()=>this.map(t))):Dt(n)}}},hn=class extends Fe{constructor(t){super(),I(this,"state","hasError"),I(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}},bt=class extends Fe{constructor(t){super(),I(this,"state","loading"),I(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Ve(this.contents.then(n=>{let o=t(n);if(ze(o)){let r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(Z(n))return n.then(()=>this.map(t).contents);throw n}))}};function lt(e){return Object.freeze(new fn(e))}function Dt(e){return Object.freeze(new hn(e))}function Ve(e){return Object.freeze(new bt(e))}function yo(){return Object.freeze(new bt(new Promise(()=>{})))}function jr(e){return e.every(t=>t.state==="hasValue")?lt(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?Dt(Y(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Ve(Promise.all(e.map(t=>t.contents)))}function go(e){let n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>ze(r)?r:Z(r)?Ve(r):lt(r)),o=jr(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,i,l)=>({...a,[i]:r[l]}),{}))}function ze(e){return e instanceof Fe}var Zr={of:e=>Z(e)?Ve(e):ze(e)?e:lt(e),error:e=>Dt(e),loading:()=>yo(),all:go,isLoadable:ze},$e={loadableWithValue:lt,loadableWithError:Dt,loadableWithPromise:Ve,loadableLoading:yo,loadableAll:go,isLoadable:ze,RecoilLoadable:Zr},Yr=$e.loadableWithValue,Xr=$e.loadableWithError,Jr=$e.loadableWithPromise,Qr=$e.loadableLoading,ea=$e.loadableAll,ta=$e.isLoadable,na=$e.RecoilLoadable,ut=Object.freeze({__proto__:null,loadableWithValue:Yr,loadableWithError:Xr,loadableWithPromise:Jr,loadableLoading:Qr,loadableAll:ea,isLoadable:ta,RecoilLoadable:na}),Ot=new Map().set("recoil_hamt_2020",!0).set("recoil_sync_external_store",!0).set("recoil_suppress_rerender_in_callback",!0).set("recoil_memory_managament_2020",!0);function kt(e){var t;return(t=Ot.get(e))!==null&&t!==void 0?t:!1}kt.setPass=e=>{Ot.set(e,!0)};kt.setFail=e=>{Ot.set(e,!1)};kt.clear=()=>{Ot.clear()};var G=kt;function oa(e,t,{error:n}={}){return null}var ra=oa,se=ra,on,rn,an,aa=(on=H.default.createMutableSource)!==null&&on!==void 0?on:H.default.unstable_createMutableSource,bo=(rn=H.default.useMutableSource)!==null&&rn!==void 0?rn:H.default.unstable_useMutableSource,Vn=(an=H.default.useSyncExternalStore)!==null&&an!==void 0?an:H.default.unstable_useSyncExternalStore,Yn=!1;function ia(){var e;let{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=H.default.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,r=((e=t?.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null;return Vn&&!r&&!Yn&&(Yn=!0,se("A React renderer without React 18+ API support is being used with React 18+.")),r}function sa(){return G("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:G("recoil_sync_external_store")&&Vn!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:G("recoil_mutable_source")&&bo!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?G("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:G("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}function ca(){return!1}var qe={createMutableSource:aa,useMutableSource:bo,useSyncExternalStore:Vn,currentRendererSupportsUseSyncExternalStore:ia,reactMode:sa,isFastRefreshEnabled:ca},To={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0};function la(){var e,t,n;if(typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)==null)return;let o=(t=process.env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED)===null||t===void 0||(n=t.toLowerCase())===null||n===void 0?void 0:n.trim();if(o==null||o==="")return;if(!["true","false"].includes(o))throw U(`process.env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED value must be 'true', 'false', or empty: ${o}`);To.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=o==="true"}la();var Eo=To,it=class{constructor(t){I(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}},Tt=class extends it{},Et=class extends it{};function ua(e){return e instanceof Tt||e instanceof Et}var Bt={AbstractRecoilValue:it,RecoilState:Tt,RecoilValueReadOnly:Et,isRecoilValue:ua},da=Bt.AbstractRecoilValue,fa=Bt.RecoilState,ha=Bt.RecoilValueReadOnly,_a=Bt.isRecoilValue,Le=Object.freeze({__proto__:null,AbstractRecoilValue:da,RecoilState:fa,RecoilValueReadOnly:ha,isRecoilValue:_a});function pa(e,...t){}var va=pa,Ln=va;function Ra(e,t){return function*(){let n=0;for(let o of e)yield t(o,n++)}()}var Pt=Ra,{isFastRefreshEnabled:Ed}=qe,wt=class{},Sa=new wt,Ce=new Map,Cn=new Map;function ma(e){return Pt(e,t=>Y(Cn.get(t)))}function ya(e){if(Ce.has(e)){let t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`}}function ga(e){Eo.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&ya(e.key),Ce.set(e.key,e);let t=e.set==null?new Le.RecoilValueReadOnly(e.key):new Le.RecoilState(e.key);return Cn.set(e.key,t),t}var Nt=class extends Error{};function ba(e){let t=Ce.get(e);if(t==null)throw new Nt(`Missing definition for RecoilValue: "${e}""`);return t}function Ta(e){return Ce.get(e)}var At=new Map;function Ea(e){var t;if(!G("recoil_memory_managament_2020"))return;let n=Ce.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ce.delete(e),(o=wo(e))===null||o===void 0||o(),At.delete(e)}}function wa(e,t){!G("recoil_memory_managament_2020")||(t===void 0?At.delete(e):At.set(e,t))}function wo(e){return At.get(e)}var de={nodes:Ce,recoilValues:Cn,registerNode:ga,getNode:ba,getNodeMaybe:Ta,deleteNodeConfigIfPossible:Ea,setConfigDeletionHandler:wa,getConfigDeletionHandler:wo,recoilValuesForKeys:ma,NodeMissingError:Nt,DefaultValue:wt,DEFAULT_VALUE:Sa};function Na(e,t){t()}var Aa={enqueueExecution:Na};function Va(e,t){return t={exports:{}},e(t,t.exports),t.exports}var La=Va(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,i=r/2,l=r/4,u={},f=function(s){return function(){return s}},_=n.hash=function(c){var s=typeof c>"u"?"undefined":t(c);if(s==="number")return c;s!=="string"&&(c+="");for(var h=0,S=0,m=c.length;S<m;++S){var g=c.charCodeAt(S);h=(h<<5)-h+g|0}return h},v=function(s){return s-=s>>1&1431655765,s=(s&858993459)+(s>>2&858993459),s=s+(s>>4)&252645135,s+=s>>8,s+=s>>16,s&127},C=function(s,h){return h>>>s&a},L=function(s){return 1<<s},y=function(s,h){return v(s&h-1)},w=function(s,h,S,m){var g=m;if(!s){var V=m.length;g=new Array(V);for(var N=0;N<V;++N)g[N]=m[N]}return g[h]=S,g},X=function(s,h,S){var m=S.length-1,g=0,V=0,N=S;if(s)g=V=h;else for(N=new Array(m);g<h;)N[V++]=S[g++];for(++g;g<=m;)N[V++]=S[g++];return s&&(N.length=m),N},ne=function(s,h,S,m){var g=m.length;if(s){for(var V=g;V>=h;)m[V--]=m[V];return m[h]=S,m}for(var N=0,A=0,M=new Array(g+1);N<h;)M[A++]=m[N++];for(M[h]=S;N<g;)M[++A]=m[N++];return M},E=1,B=2,J=3,z=4,K={__hamt_isEmpty:!0},Q=function(s){return s===K||s&&s.__hamt_isEmpty},ce=function(s,h,S,m){return{type:E,edit:s,hash:h,key:S,value:m,_modify:De}},ye=function(s,h,S){return{type:B,edit:s,hash:h,children:S,_modify:Oe}},F=function(s,h,S){return{type:J,edit:s,mask:h,children:S,_modify:P}},ae=function(s,h,S){return{type:z,edit:s,size:h,children:S,_modify:x}},Ne=function(s){return s===K||s.type===E||s.type===B},re=function(s,h,S,m,g){for(var V=[],N=m,A=0,M=0;N;++M)N&1&&(V[M]=g[A++]),N>>>=1;return V[h]=S,ae(s,A+1,V)},fe=function(s,h,S,m){for(var g=new Array(h-1),V=0,N=0,A=0,M=m.length;A<M;++A)if(A!==S){var j=m[A];j&&!Q(j)&&(g[V++]=j,N|=1<<A)}return F(s,N,g)},Ue=function c(s,h,S,m,g,V){if(S===g)return ye(s,S,[V,m]);var N=C(h,S),A=C(h,g);return F(s,L(N)|L(A),N===A?[c(s,h+o,S,m,g,V)]:N<A?[m,V]:[V,m])},Me=function(s,h,S,m,g,V,N,A){for(var M=g.length,j=0;j<M;++j){var le=g[j];if(S(N,le.key)){var oe=le.value,pe=V(oe);return pe===oe?g:pe===u?(--A.value,X(s,j,g)):w(s,j,ce(h,m,N,pe),g)}}var ve=V();return ve===u?g:(++A.value,w(s,M,ce(h,m,N,ve),g))},ge=function(s,h){return s===h.edit},De=function(s,h,S,m,g,V,N){if(h(V,this.key)){var A=m(this.value);return A===this.value?this:A===u?(--N.value,K):ge(s,this)?(this.value=A,this):ce(s,g,V,A)}var M=m();return M===u?this:(++N.value,Ue(s,S,this.hash,this,g,ce(s,g,V,M)))},Oe=function(s,h,S,m,g,V,N){if(g===this.hash){var A=ge(s,this),M=Me(A,s,h,this.hash,this.children,m,V,N);return M===this.children?this:M.length>1?ye(s,this.hash,M):M[0]}var j=m();return j===u?this:(++N.value,Ue(s,S,this.hash,this,g,ce(s,g,V,j)))},P=function(s,h,S,m,g,V,N){var A=this.mask,M=this.children,j=C(S,g),le=L(j),oe=y(A,le),pe=A&le,ve=pe?M[oe]:K,Be=ve._modify(s,h,S+o,m,g,V,N);if(ve===Be)return this;var pt=ge(s,this),Ze=A,Ye=void 0;if(pe&&Q(Be)){if(Ze&=~le,!Ze)return K;if(M.length<=2&&Ne(M[oe^1]))return M[oe^1];Ye=X(pt,oe,M)}else if(!pe&&!Q(Be)){if(M.length>=i)return re(s,j,Be,A,M);Ze|=le,Ye=ne(pt,oe,Be,M)}else Ye=w(pt,oe,Be,M);return pt?(this.mask=Ze,this.children=Ye,this):F(s,Ze,Ye)},x=function(s,h,S,m,g,V,N){var A=this.size,M=this.children,j=C(S,g),le=M[j],oe=(le||K)._modify(s,h,S+o,m,g,V,N);if(le===oe)return this;var pe=ge(s,this),ve=void 0;if(Q(le)&&!Q(oe))++A,ve=w(pe,j,oe,M);else if(!Q(le)&&Q(oe)){if(--A,A<=l)return fe(s,A,j,M);ve=w(pe,j,K,M)}else ve=w(pe,j,oe,M);return pe?(this.size=A,this.children=ve,this):ae(s,A,ve)};K._modify=function(c,s,h,S,m,g,V){var N=S();return N===u?K:(++V.value,ce(c,m,g,N))};function d(c,s,h,S,m){this._editable=c,this._edit=s,this._config=h,this._root=S,this._size=m}d.prototype.setTree=function(c,s){return this._editable?(this._root=c,this._size=s,this):c===this._root?this:new d(this._editable,this._edit,this._config,c,s)};var p=n.tryGetHash=function(c,s,h,S){for(var m=S._root,g=0,V=S._config.keyEq;;)switch(m.type){case E:return V(h,m.key)?m.value:c;case B:{if(s===m.hash)for(var N=m.children,A=0,M=N.length;A<M;++A){var j=N[A];if(V(h,j.key))return j.value}return c}case J:{var le=C(g,s),oe=L(le);if(m.mask&oe){m=m.children[y(m.mask,oe)],g+=o;break}return c}case z:{if(m=m.children[C(g,s)],m){g+=o;break}return c}default:return c}};d.prototype.tryGetHash=function(c,s,h){return p(c,s,h,this)};var R=n.tryGet=function(c,s,h){return p(c,h._config.hash(s),s,h)};d.prototype.tryGet=function(c,s){return R(c,s,this)};var $=n.getHash=function(c,s,h){return p(void 0,c,s,h)};d.prototype.getHash=function(c,s){return $(c,s,this)};var b=n.get=function(c,s){return p(void 0,s._config.hash(c),c,s)};d.prototype.get=function(c,s){return R(s,c,this)};var O=n.has=function(c,s,h){return p(u,c,s,h)!==u};d.prototype.hasHash=function(c,s){return O(c,s,this)};var k=n.has=function(c,s){return O(s._config.hash(c),c,s)};d.prototype.has=function(c){return k(c,this)};var T=function(s,h){return s===h};n.make=function(c){return new d(0,0,{keyEq:c&&c.keyEq||T,hash:c&&c.hash||_},K,0)},n.empty=n.make();var te=n.isEmpty=function(c){return c&&!!Q(c._root)};d.prototype.isEmpty=function(){return te(this)};var ee=n.modifyHash=function(c,s,h,S){var m={value:S._size},g=S._root._modify(S._editable?S._edit:NaN,S._config.keyEq,0,c,s,h,m);return S.setTree(g,m.value)};d.prototype.modifyHash=function(c,s,h){return ee(h,c,s,this)};var W=n.modify=function(c,s,h){return ee(c,h._config.hash(s),s,h)};d.prototype.modify=function(c,s){return W(s,c,this)};var q=n.setHash=function(c,s,h,S){return ee(f(h),c,s,S)};d.prototype.setHash=function(c,s,h){return q(c,s,h,this)};var he=n.set=function(c,s,h){return q(h._config.hash(c),c,s,h)};d.prototype.set=function(c,s){return he(c,s,this)};var ke=f(u),ie=n.removeHash=function(c,s,h){return ee(ke,c,s,h)};d.prototype.removeHash=d.prototype.deleteHash=function(c,s){return ie(c,s,this)};var _e=n.remove=function(c,s){return ie(s._config.hash(c),c,s)};d.prototype.remove=d.prototype.delete=function(c){return _e(c,this)};var Gn=n.beginMutation=function(c){return new d(c._editable+1,c._edit+1,c._config,c._root,c._size)};d.prototype.beginMutation=function(){return Gn(this)};var Hn=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};d.prototype.endMutation=function(){return Hn(this)};var Ir=n.mutate=function(c,s){var h=Gn(s);return c(h),Hn(h)};d.prototype.mutate=function(c){return Ir(c,this)};var en=function(s){return s&&Kn(s[0],s[1],s[2],s[3],s[4])},Kn=function(s,h,S,m,g){for(;S<s;){var V=h[S++];if(V&&!Q(V))return qn(V,m,[s,h,S,m,g])}return en(g)},qn=function(s,h,S){switch(s.type){case E:return{value:h(s),rest:S};case B:case z:case J:var m=s.children;return Kn(m.length,m,0,h,S);default:return en(S)}},Ur={done:!0};function tn(c){this.v=c}tn.prototype.next=function(){if(!this.v)return Ur;var c=this.v;return this.v=en(c.rest),c},tn.prototype[Symbol.iterator]=function(){return this};var nn=function(s,h){return new tn(qn(s._root,h))},Mr=function(s){return[s.key,s.value]},Dr=n.entries=function(c){return nn(c,Mr)};d.prototype.entries=d.prototype[Symbol.iterator]=function(){return Dr(this)};var Or=function(s){return s.key},kr=n.keys=function(c){return nn(c,Or)};d.prototype.keys=function(){return kr(this)};var Br=function(s){return s.value},Pr=n.values=d.prototype.values=function(c){return nn(c,Br)};d.prototype.values=function(){return Pr(this)};var jn=n.fold=function(c,s,h){var S=h._root;if(S.type===E)return c(s,S.value,S.key);for(var m=[S.children],g=void 0;g=m.pop();)for(var V=0,N=g.length;V<N;){var A=g[V++];A&&A.type&&(A.type===E?s=c(s,A.value,A.key):m.push(A.children))}return s};d.prototype.fold=function(c,s){return jn(c,s,this)};var xr=n.forEach=function(c,s){return jn(function(h,S,m){return c(S,m,s)},null,s)};d.prototype.forEach=function(c){return xr(c,this)};var Fr=n.count=function(c){return c._size};d.prototype.count=function(){return Fr(this)},Object.defineProperty(d.prototype,"size",{get:d.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n}),_n=class{constructor(t){I(this,"_map",void 0),this._map=new Map(t?.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return $n(this)}toMap(){return new Map(this._map)}},st=class{constructor(t){if(I(this,"_hamt",La.empty.beginMutation()),t instanceof st){let n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(let[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return $n(this)}toMap(){return new Map(this._hamt)}};function $n(e){return G("recoil_hamt_2020")?new st(e):new _n(e)}var Ca={persistentMap:$n},$a=Ca.persistentMap,Ia=Object.freeze({__proto__:null,persistentMap:$a});function Ua(e,...t){let n=new Set;e:for(let o of e){for(let r of t)if(r.has(o))continue e;n.add(o)}return n}var ot=Ua;function Ma(e,t){let n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var Vt=Ma;function Da(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function Oa(e){return{nodeDeps:Vt(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:Vt(e.nodeToNodeSubscriptions,t=>new Set(t))}}function sn(e,t,n,o){let{nodeDeps:r,nodeToNodeSubscriptions:a}=n,i=r.get(e);if(i&&o&&i!==o.nodeDeps.get(e))return;r.set(e,t);let l=i==null?t:ot(t,i);for(let u of l)a.has(u)||a.set(u,new Set),Y(a.get(u)).add(e);if(i){let u=ot(i,t);for(let f of u){if(!a.has(f))return;let _=Y(a.get(f));_.delete(e),_.size===0&&a.delete(f)}}}function ka(e,t,n,o){var r,a,i,l;let u=n.getState();o===u.currentTree.version||o===((r=u.nextTree)===null||r===void 0?void 0:r.version)||o===((a=u.previousTree)===null||a===void 0?void 0:a.version)||se("Tried to save dependencies to a discarded tree");let f=n.getGraph(o);if(sn(e,t,f),o===((i=u.previousTree)===null||i===void 0?void 0:i.version)){let v=n.getGraph(u.currentTree.version);sn(e,t,v,f)}if(o===((l=u.previousTree)===null||l===void 0?void 0:l.version)||o===u.currentTree.version){var _;let v=(_=u.nextTree)===null||_===void 0?void 0:_.version;if(v!==void 0){let C=n.getGraph(v);sn(e,t,C,f)}}}var dt={cloneGraph:Oa,graph:Da,saveDepsToStore:ka},Ba=0,Pa=()=>Ba++,xa=0,Fa=()=>xa++,za=0,Wa=()=>za++,xt={getNextTreeStateVersion:Pa,getNextStoreID:Fa,getNextComponentID:Wa},{persistentMap:Xn}=Ia,{graph:Ga}=dt,{getNextTreeStateVersion:No}=xt;function Ao(){let e=No();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Xn(),nonvalidatedAtoms:Xn()}}function Ha(){let e=Ao();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,Ga()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var Vo={makeEmptyTreeState:Ao,makeEmptyStoreState:Ha,getNextTreeStateVersion:No},Lt=class{};function Ka(){return new Lt}var Ft={RetentionZone:Lt,retentionZone:Ka};function qa(e,t){let n=new Set(e);return n.add(t),n}function ja(e,t){let n=new Set(e);return n.delete(t),n}function Za(e,t,n){let o=new Map(e);return o.set(t,n),o}function Ya(e,t,n){let o=new Map(e);return o.set(t,n(o.get(t))),o}function Xa(e,t){let n=new Map(e);return n.delete(t),n}function Ja(e,t){let n=new Map(e);return t.forEach(o=>n.delete(o)),n}var Lo={setByAddingToSet:qa,setByDeletingFromSet:ja,mapBySettingInMap:Za,mapByUpdatingInMap:Ya,mapByDeletingFromMap:Xa,mapByDeletingMultipleFromMap:Ja};function*Qa(e,t){let n=0;for(let o of e)t(o,n++)&&(yield o)}var In=Qa;function ei(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var Co=ei,{getNode:ft,getNodeMaybe:ti,recoilValuesForKeys:Jn}=de,{RetentionZone:Qn}=Ft,{setByAddingToSet:ni}=Lo,oi=Object.freeze(new Set),pn=class extends Error{};function ri(e,t,n){if(!G("recoil_memory_managament_2020"))return()=>{};let{nodesRetainedByZone:o}=e.getState().retention;function r(a){let i=o.get(a);i||o.set(a,i=new Set),i.add(t)}if(n instanceof Qn)r(n);else if(Array.isArray(n))for(let a of n)r(a);return()=>{if(!G("recoil_memory_managament_2020"))return;let{retention:a}=e.getState();function i(l){let u=a.nodesRetainedByZone.get(l);u?.delete(t),u&&u.size===0&&a.nodesRetainedByZone.delete(l)}if(n instanceof Qn)i(n);else if(Array.isArray(n))for(let l of n)i(l)}}function Un(e,t,n,o){let r=e.getState();if(r.nodeCleanupFunctions.has(n))return;let a=ft(n),i=ri(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),i()})}function ai(e,t,n){Un(e,e.getState().currentTree,t,n)}function ii(e,t){var n;let o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function si(e,t,n){return Un(e,t,n,"get"),ft(n).get(e,t)}function $o(e,t,n){return ft(n).peek(e,t)}function ci(e,t,n){var o;let r=ti(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:ni(e.dirtyAtoms,t)}}function li(e,t,n,o){let r=ft(n);if(r.set==null)throw new pn(`Attempt to set read-only RecoilValue: ${n}`);let a=r.set;return Un(e,t,n,"set"),a(e,t,o)}function ui(e,t,n){let o=e.getState(),r=e.getGraph(t.version),a=ft(n).nodeType;return Co({type:a},{loadable:()=>$o(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var i;return Jn((i=r.nodeDeps.get(n))!==null&&i!==void 0?i:[])},subscribers:()=>{var i,l;return{nodes:Jn(In(Io(e,t,new Set([n])),u=>u!==n)),components:Pt((i=(l=o.nodeToComponentSubscriptions.get(n))===null||l===void 0?void 0:l.values())!==null&&i!==void 0?i:[],([u])=>({name:u}))}}})}function Io(e,t,n){let o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let l=r.pop();l;l=r.pop()){var i;o.add(l);let u=(i=a.nodeToNodeSubscriptions.get(l))!==null&&i!==void 0?i:oi;for(let f of u)o.has(f)||r.push(f)}return o}var Ee={getNodeLoadable:si,peekNodeLoadable:$o,setNodeValue:li,initializeNode:ai,cleanUpNode:ii,setUnvalidatedAtomValue_DEPRECATED:ci,peekNodeInfo:ui,getDownstreamNodes:Io},Uo=null;function di(e){Uo=e}function fi(){var e;(e=Uo)===null||e===void 0||e()}var Mo={setInvalidateMemoizedSnapshot:di,invalidateMemoizedSnapshot:fi},{getDownstreamNodes:hi,getNodeLoadable:Do,setNodeValue:_i}=Ee,{getNextComponentID:pi}=xt,{getNode:vi,getNodeMaybe:Oo}=de,{DefaultValue:Mn}=de,{reactMode:Ri}=qe,{AbstractRecoilValue:Si,RecoilState:mi,RecoilValueReadOnly:yi,isRecoilValue:gi}=Le,{invalidateMemoizedSnapshot:bi}=Mo;function Ti(e,{key:t},n=e.getState().currentTree){var o,r;let a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||n.version===((r=a.previousTree)===null||r===void 0?void 0:r.version)||se("Tried to read from a discarded tree");let i=Do(e,n,t);return i.state==="loading"&&i.contents.catch(()=>{}),i}function Ei(e,t){let n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof Mn?n.delete(r):n.set(r,o)}),n}function wi(e,t,{key:n},o){if(typeof o=="function"){let r=Do(e,t,n);if(r.state==="loading"){let a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw se(a),U(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function Ni(e,t,n){if(n.type==="set"){let{recoilValue:r,valueOrUpdater:a}=n,i=wi(e,t,r,a),l=_i(e,t,r.key,i);for(let[u,f]of l.entries())vn(t,u,f)}else if(n.type==="setLoadable"){let{recoilValue:{key:r},loadable:a}=n;vn(t,r,a)}else if(n.type==="markModified"){let{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;let{recoilValue:{key:r},unvalidatedValue:a}=n,i=Oo(r);i==null||(o=i.invalidate)===null||o===void 0||o.call(i,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else se(`Unknown action ${n.type}`)}function vn(e,t,n){n.state==="hasValue"&&n.contents instanceof Mn?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function ko(e,t){e.replaceState(n=>{let o=Bo(n);for(let r of t)Ni(e,o,r);return Po(e,o),bi(),o})}function zt(e,t){if(rt.length){let n=rt[rt.length-1],o=n.get(e);o||n.set(e,o=[]),o.push(t)}else ko(e,[t])}var rt=[];function Ai(){let e=new Map;return rt.push(e),()=>{for(let[n,o]of e)ko(n,o);rt.pop()!==e&&se("Incorrect order of batch popping")}}function Bo(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function Po(e,t){let n=hi(e,t,t.dirtyAtoms);for(let a of n){var o,r;(o=Oo(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function xo(e,t,n){zt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function Vi(e,t,n){if(n instanceof Mn)return xo(e,t,n);zt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function Li(e,t){zt(e,{type:"markModified",recoilValue:t})}function Ci(e,t,n){zt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function $i(e,{key:t},n,o=null){let r=pi(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),Y(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);let i=Ri();if(i.early&&(i.mode==="LEGACY"||i.mode==="MUTABLE_SOURCE")){let l=e.getState().nextTree;l&&l.dirtyAtoms.has(t)&&n(l)}return{release:()=>{let l=e.getState(),u=l.nodeToComponentSubscriptions.get(t);if(u===void 0||!u.has(r)){se(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`);return}u.delete(r),u.size===0&&l.nodeToComponentSubscriptions.delete(t)}}}function Ii(e,t){var n;let{currentTree:o}=e.getState(),r=vi(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var Se={RecoilValueReadOnly:yi,AbstractRecoilValue:Si,RecoilState:mi,getRecoilValueAsLoadable:Ti,setRecoilValue:xo,setRecoilValueLoadable:Vi,markRecoilValueModified:Li,setUnvalidatedRecoilValue:Ci,subscribeToRecoilValue:$i,isRecoilValue:gi,applyAtomValueWrites:Ei,batchStart:Ai,writeLoadableToTreeState:vn,invalidateDownstreams:Po,copyTreeState:Bo,refreshRecoilValue:Ii};function Ui(e,t,n){let o=e.entries(),r=o.next();for(;!r.done;){let a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var Mi=Ui,{cleanUpNode:Di}=Ee,{deleteNodeConfigIfPossible:Oi,getNode:Fo}=de,{RetentionZone:zo}=Ft,ki=12e4,Wo=new Set;function Go(e,t){let n=e.getState(),o=n.currentTree;if(n.nextTree){se("releaseNodesNowOnCurrentTree should only be called at the end of a batch");return}let r=new Set;for(let i of t)if(i instanceof zo)for(let l of Fi(n,i))r.add(l);else r.add(i);let a=Bi(e,r);for(let i of a)xi(e,o,i)}function Bi(e,t){let n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,i=new Set;return l(t),a;function l(u){let f=new Set,_=Pi(e,o,u,a,i);for(let y of _){var v;if(Fo(y).retainedBy==="recoilRoot"){i.add(y);continue}if(((v=n.retention.referenceCounts.get(y))!==null&&v!==void 0?v:0)>0){i.add(y);continue}if(Ho(y).some(X=>n.retention.referenceCounts.get(X))){i.add(y);continue}let w=r.nodeToNodeSubscriptions.get(y);if(w&&Mi(w,X=>i.has(X))){i.add(y);continue}a.add(y),f.add(y)}let C=new Set;for(let y of f)for(let w of(L=r.nodeDeps.get(y))!==null&&L!==void 0?L:Wo){var L;a.has(w)||C.add(w)}C.size&&l(C)}}function Pi(e,t,n,o,r){let a=e.getGraph(t.version),i=[],l=new Set;for(;n.size>0;)u(Y(n.values().next().value));return i;function u(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(l.has(f))return;let _=a.nodeToNodeSubscriptions.get(f);if(_)for(let v of _)u(v);l.add(f),n.delete(f),i.push(f)}}function xi(e,t,n){if(!G("recoil_memory_managament_2020"))return;Di(e,n);let o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);let r=Ho(n);for(let u of r){var a;(a=o.retention.nodesRetainedByZone.get(u))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);let i=o.graphsByVersion.get(t.version);if(i){let u=i.nodeDeps.get(n);if(u!==void 0){i.nodeDeps.delete(n);for(let f of u){var l;(l=i.nodeToNodeSubscriptions.get(f))===null||l===void 0||l.delete(n)}}i.nodeToNodeSubscriptions.delete(n)}Oi(n)}function Fi(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:Wo}function Ho(e){let t=Fo(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof zo?[t]:t}function zi(e,t){let n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):Go(e,new Set([t]))}function Wi(e,t,n){var o;if(!G("recoil_memory_managament_2020"))return;let r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Ko(e,t):r.set(t,a)}function Ko(e,t){if(!G("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),zi(e,t)}function Gi(e){if(!G("recoil_memory_managament_2020"))return;let t=e.getState();Go(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Hi(e){return e===void 0?"recoilRoot":e}var Ie={SUSPENSE_TIMEOUT_MS:ki,updateRetainCount:Wi,updateRetainCountToZero:Ko,releaseScheduledRetainablesNow:Gi,retainedByOptionWithDefault:Hi},{unstable_batchedUpdates:Ki}=mo.default,qi={unstable_batchedUpdates:Ki},{unstable_batchedUpdates:ji}=qi,Zi={unstable_batchedUpdates:ji},{batchStart:Yi}=Se,{unstable_batchedUpdates:Xi}=Zi,Dn=Xi,Ji=e=>{Dn=e},Qi=()=>Dn,es=e=>{Dn(()=>{let t=()=>{};try{t=Yi(),e()}finally{t()}})},Wt={getBatcher:Qi,setBatcher:Ji,batchUpdates:es};function*ts(e){for(let t of e)for(let n of t)yield n}var qo=ts,jo=typeof Window>"u"||typeof window>"u",ns=e=>!jo&&(e===window||e instanceof Window),os=typeof navigator<"u"&&navigator.product==="ReactNative",Gt={isSSR:jo,isReactNative:os,isWindow:ns};function rs(e,t){let n;return(...r)=>{n||(n={});let a=t(...r);return Object.hasOwnProperty.call(n,a)||(n[a]=e(...r)),n[a]}}function as(e,t){let n,o;return(...a)=>{let i=t(...a);return n===i||(n=i,o=e(...a)),o}}function is(e,t){let n,o;return[(...i)=>{let l=t(...i);return n===l||(n=l,o=e(...i)),o},()=>{n=null}]}var ss={memoizeWithArgsHash:rs,memoizeOneWithArgsHash:as,memoizeOneWithArgsHashAndInvalidation:is},{batchUpdates:Rn}=Wt,{initializeNode:cs,peekNodeInfo:ls}=Ee,{graph:us}=dt,{getNextStoreID:ds}=xt,{DEFAULT_VALUE:fs,recoilValues:eo,recoilValuesForKeys:to}=de,{AbstractRecoilValue:hs,getRecoilValueAsLoadable:_s,setRecoilValue:no,setUnvalidatedRecoilValue:ps}=Se,{updateRetainCount:gt}=Ie,{setInvalidateMemoizedSnapshot:vs}=Mo,{getNextTreeStateVersion:Rs,makeEmptyStoreState:Ss}=Vo,{isSSR:ms}=Gt,{memoizeOneWithArgsHashAndInvalidation:ys}=ss;var We=class{constructor(t,n){I(this,"_store",void 0),I(this,"_refCount",1),I(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),_s(this._store,o))),I(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),I(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),o?.isModified===!0){if(o?.isInitialized===!1)return[];let i=this._store.getState().currentTree;return to(i.dirtyAtoms)}let r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return o?.isInitialized==null?eo.values():o.isInitialized===!0?to(qo([r,a])):In(eo.values(),({key:i})=>!r.has(i)&&!a.has(i))}),I(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),ls(this._store,this._store.getState().currentTree,o))),I(this,"map",o=>{this.checkRefCount_INTERNAL();let r=new ct(this,Rn);return o(r),r}),I(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();let r=new ct(this,Rn);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:ds(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{let r=t.graphsByVersion;if(r.has(o))return Y(r.get(o));let a=us();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw U("Cannot subscribe to Snapshots")}};for(let o of this._store.getState().knownAtoms)cs(this._store,o,"get"),gt(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&se("Attempt to retain() Snapshot that was already released."),this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){ms||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!G("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){G("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}};function Zo(e,t,n=!1){let o=e.getState(),r=n?Rs():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(Pt(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function gs(e){let t=new We(Ss());return e!=null?t.map(e):t}var[oo,Yo]=ys((e,t)=>{var n;let o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:Y(o.previousTree);return new We(Zo(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});vs(Yo);function bs(e,t="latest"){let n=oo(e,t);return n.isRetained()?n:(Yo(),oo(e,t))}var ct=class extends We{constructor(t,n){super(Zo(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),I(this,"_batch",void 0),I(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();let a=this.getStore_INTERNAL();this._batch(()=>{gt(a,o.key,1),no(this.getStore_INTERNAL(),o,r)})}),I(this,"reset",o=>{this.checkRefCount_INTERNAL();let r=this.getStore_INTERNAL();this._batch(()=>{gt(r,o.key,1),no(this.getStore_INTERNAL(),o,fs)})}),I(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();let r=this.getStore_INTERNAL();Rn(()=>{for(let[a,i]of o.entries())gt(r,a,1),ps(r,new hs(a),i)})}),this._batch=n}},Ht={Snapshot:We,MutableSnapshot:ct,freshSnapshot:gs,cloneSnapshot:bs},Ts=Ht.Snapshot,Es=Ht.MutableSnapshot,ws=Ht.freshSnapshot,Ns=Ht.cloneSnapshot,Kt=Object.freeze({__proto__:null,Snapshot:Ts,MutableSnapshot:Es,freshSnapshot:ws,cloneSnapshot:Ns});function As(...e){let t=new Set;for(let n of e)for(let o of n)t.add(o);return t}var Vs=As,{useRef:Ls}=H.default;function Cs(e){let t=Ls(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var ro=Cs,{getNextTreeStateVersion:$s,makeEmptyStoreState:Xo}=Vo,{cleanUpNode:Is,getDownstreamNodes:Us,initializeNode:Ms,setNodeValue:Ds,setUnvalidatedAtomValue_DEPRECATED:Os}=Ee,{graph:ks}=dt,{cloneGraph:Bs}=dt,{getNextStoreID:Jo}=xt,{createMutableSource:cn,reactMode:Qo}=qe,{applyAtomValueWrites:Ps}=Se,{releaseScheduledRetainablesNow:er}=Ie,{freshSnapshot:xs}=Kt,{useCallback:Fs,useContext:tr,useEffect:Sn,useMemo:zs,useRef:Ws,useState:Gs}=H.default;function Xe(){throw U("This component must be used inside a <RecoilRoot> component.")}var nr=Object.freeze({storeID:Jo(),getState:Xe,replaceState:Xe,getGraph:Xe,subscribeToTransactions:Xe,addTransactionMetadata:Xe}),mn=!1;function ao(e){if(mn)throw U("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");let t=e.getState();if(t.nextTree===null){G("recoil_memory_managament_2020")&&G("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&er(e);let n=t.currentTree.version,o=$s();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Bs(Y(t.graphsByVersion.get(n))))}}var or=H.default.createContext({current:nr}),qt=()=>tr(or),rr=H.default.createContext(null);function Hs(){let e=tr(rr);return e==null&&Ln("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e}function On(e,t,n){let o=Us(e,n,n.dirtyAtoms);for(let r of o){let a=t.nodeToComponentSubscriptions.get(r);if(a)for(let[i,[l,u]]of a)u(n)}}function ar(e){let t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(let[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(let[i,l]of a)l(e);for(let[r,a]of t.transactionSubscriptions)a(e);(!Qo().early||t.suspendedComponentResolvers.size>0)&&(On(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Ks(e){let t=e.getState();t.commitDepth++;try{let{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,ar(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):se("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,G("recoil_memory_managament_2020")&&n==null&&er(e)}finally{t.commitDepth--}}function qs({setNotifyBatcherOfChange:e}){let t=qt(),[,n]=Gs([]);return e(()=>n({})),Sn(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),Sn(()=>{Aa.enqueueExecution("Batcher",()=>{Ks(t.current)})}),null}function js(e,t){let n=Xo();return t({set:(o,r)=>{let a=n.currentTree,i=Ds(e,a,o.key,r),l=new Set(i.keys()),u=a.nonvalidatedAtoms.clone();for(let f of l)u.delete(f);n.currentTree={...a,dirtyAtoms:Vs(a.dirtyAtoms,l),atomValues:Ps(a.atomValues,i),nonvalidatedAtoms:u}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=Os(n.currentTree,a,r)})}}),n}function Zs(e){let t=xs(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}var io=0;function Ys({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r,a=L=>{let y=r.current.graphsByVersion;if(y.has(L))return Y(y.get(L));let w=ks();return y.set(L,w),w},i=(L,y)=>{if(y==null){let{transactionSubscriptions:w}=v.current.getState(),X=io++;return w.set(X,L),{release:()=>{w.delete(X)}}}else{let{nodeTransactionSubscriptions:w}=v.current.getState();w.has(y)||w.set(y,new Map);let X=io++;return Y(w.get(y)).set(X,L),{release:()=>{let ne=w.get(y);ne&&(ne.delete(X),ne.size===0&&w.delete(y))}}}},l=L=>{ao(v.current);for(let y of Object.keys(L))Y(v.current.getState().nextTree).transactionMetadata[y]=L[y]},u=L=>{ao(v.current);let y=Y(r.current.nextTree),w;try{mn=!0,w=L(y)}finally{mn=!1}w!==y&&(r.current.nextTree=w,Qo().early&&On(v.current,r.current,w),Y(f.current)())},f=Ws(null),_=Fs(L=>{f.current=L},[f]),v=ro(()=>n??{storeID:Jo(),getState:()=>r.current,replaceState:u,getGraph:a,subscribeToTransactions:i,addTransactionMetadata:l});n!=null&&(v.current=n),r=ro(()=>e!=null?js(v.current,e):t!=null?Zs(t):Xo());let C=zs(()=>cn?.(r,()=>r.current.currentTree.version),[r]);return Sn(()=>{let L=v.current;for(let y of new Set(L.getState().knownAtoms))Ms(L,y,"get");return()=>{for(let y of L.getState().knownAtoms)Is(L,y)}},[v]),H.default.createElement(or.Provider,{value:v},H.default.createElement(rr.Provider,{value:C},H.default.createElement(qs,{setNotifyBatcherOfChange:_}),o))}function Xs(e){let{override:t,...n}=e,o=qt();return t===!1&&o.current!==nr?e.children:H.default.createElement(Ys,n)}function Js(){return qt().current.storeID}var be={RecoilRoot:Xs,useStoreRef:qt,useRecoilMutableSource:Hs,useRecoilStoreID:Js,notifyComponents_FOR_TESTING:On,sendEndOfBatchNotifications_FOR_TESTING:ar};function Qs(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var ec=Qs,{useEffect:tc,useRef:nc}=H.default;function oc(e){let t=nc();return tc(()=>{t.current=e}),t.current}var ir=oc,{useStoreRef:rc}=be,{SUSPENSE_TIMEOUT_MS:ac}=Ie,{updateRetainCount:Je}=Ie,{RetentionZone:ic}=Ft,{useEffect:sc,useRef:cc}=H.default,{isSSR:so}=Gt;function lc(e){if(!!G("recoil_memory_managament_2020"))return uc(e)}function uc(e){let n=(Array.isArray(e)?e:[e]).map(i=>i instanceof ic?i:i.key),o=rc();sc(()=>{if(!G("recoil_memory_managament_2020"))return;let i=o.current;if(r.current&&!so)window.clearTimeout(r.current),r.current=null;else for(let l of n)Je(i,l,1);return()=>{for(let l of n)Je(i,l,-1)}},[o,...n]);let r=cc(),a=ir(n);if(!so&&(a===void 0||!ec(a,n))){let i=o.current;for(let l of n)Je(i,l,1);if(a)for(let l of a)Je(i,l,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(let l of n)Je(i,l,-1)},ac)}}var kn=lc;function dc(){return"<component name not available>"}var ht=dc,{batchUpdates:fc}=Wt,{DEFAULT_VALUE:sr}=de,{currentRendererSupportsUseSyncExternalStore:hc,reactMode:je,useMutableSource:_c,useSyncExternalStore:pc}=qe,{useRecoilMutableSource:vc,useStoreRef:me}=be,{isRecoilValue:wd}=Le,{AbstractRecoilValue:yn,getRecoilValueAsLoadable:_t,setRecoilValue:Ct,setUnvalidatedRecoilValue:Rc,subscribeToRecoilValue:Ge}=Se,{useCallback:ue,useEffect:He,useMemo:cr,useRef:at,useState:Bn}=H.default,{setByAddingToSet:Sc}=Lo;function Pn(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{n.current.getState().suspendedComponentResolvers.add(r)}):e.state==="hasError"?e.contents:U(`Invalid value of loadable atom "${t.key}"`)}function mc(){let e=ht(),t=me(),[,n]=Bn([]),o=at(new Set);o.current=new Set;let r=at(new Set),a=at(new Map),i=ue(u=>{let f=a.current.get(u);f&&(f.release(),a.current.delete(u))},[a]),l=ue((u,f)=>{a.current.has(f)&&n([])},[]);return He(()=>{let u=t.current;ot(o.current,r.current).forEach(f=>{if(a.current.has(f)){Ln(`Double subscription to RecoilValue "${f}"`);return}let _=Ge(u,new yn(f),C=>l(C,f),e);a.current.set(f,_),u.getState().nextTree?u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(u.getState(),f)}):l(u.getState(),f)}),ot(r.current,o.current).forEach(f=>{i(f)}),r.current=o.current}),He(()=>{let u=a.current;return ot(o.current,new Set(u.keys())).forEach(f=>{let _=Ge(t.current,new yn(f),v=>l(v,f),e);u.set(f,_)}),()=>u.forEach((f,_)=>i(_))},[e,t,i,l]),cr(()=>{function u(y){return w=>{Ct(t.current,y,w)}}function f(y){return()=>Ct(t.current,y,sr)}function _(y){var w;o.current.has(y.key)||(o.current=Sc(o.current,y.key));let X=t.current.getState();return _t(t.current,y,je().early&&(w=X.nextTree)!==null&&w!==void 0?w:X.currentTree)}function v(y){let w=_(y);return Pn(w,y,t)}function C(y){return[v(y),u(y)]}function L(y){return[_(y),u(y)]}return{getRecoilValue:v,getRecoilValueLoadable:_,getRecoilState:C,getRecoilStateLoadable:L,getSetRecoilState:u,getResetRecoilState:f}},[o,t])}var yc={current:0};function gc(e){let t=me(),n=ht(),o=ue(()=>{var l;let u=t.current,f=u.getState(),_=je().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return{loadable:_t(u,e,_),key:e.key}},[t,e]),r=ue(l=>{let u;return()=>{var f,_;let v=l();return(f=u)!==null&&f!==void 0&&f.loadable.is(v.loadable)&&((_=u)===null||_===void 0?void 0:_.key)===v.key?u:(u=v,v)}},[]),a=cr(()=>r(o),[o,r]),i=ue(l=>{let u=t.current;return Ge(u,e,l,n).release},[t,e,n]);return pc(i,a,a).loadable}function bc(e){let t=me(),n=ue(()=>{var f;let _=t.current,v=_.getState(),C=je().early&&(f=v.nextTree)!==null&&f!==void 0?f:v.currentTree;return _t(_,e,C)},[t,e]),o=ue(()=>n(),[n]),r=ht(),a=ue((f,_)=>{let v=t.current;return Ge(v,e,()=>{if(!G("recoil_suppress_rerender_in_callback"))return _();let L=n();u.current.is(L)||_(),u.current=L},r).release},[t,e,r,n]),i=vc();if(i==null)throw U("Recoil hooks must be used in components contained within a <RecoilRoot> component.");let l=_c(i,o,a),u=at(l);return He(()=>{u.current=l}),l}function gn(e){let t=me(),n=ht(),o=ue(()=>{var u;let f=t.current,_=f.getState(),v=je().early&&(u=_.nextTree)!==null&&u!==void 0?u:_.currentTree;return _t(f,e,v)},[t,e]),r=ue(()=>({loadable:o(),key:e.key}),[o,e.key]),a=ue(u=>{let f=r();return u.loadable.is(f.loadable)&&u.key===f.key?u:f},[r]);He(()=>{let u=Ge(t.current,e,f=>{l(a)},n);return l(a),u.release},[n,e,t,a]);let[i,l]=Bn(r);return i.key!==e.key?r().loadable:i.loadable}function Tc(e){let t=me(),[,n]=Bn([]),o=ht(),r=ue(()=>{var l;let u=t.current,f=u.getState(),_=je().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return _t(u,e,_)},[t,e]),a=r(),i=at(a);return He(()=>{i.current=a}),He(()=>{let l=t.current,u=l.getState(),f=Ge(l,e,v=>{var C;if(!G("recoil_suppress_rerender_in_callback"))return n([]);let L=r();(C=i.current)!==null&&C!==void 0&&C.is(L)||n(L),i.current=L},o);if(u.nextTree)l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{i.current=null,n([])});else{var _;if(!G("recoil_suppress_rerender_in_callback"))return n([]);let v=r();(_=i.current)!==null&&_!==void 0&&_.is(v)||n(v),i.current=v}return f.release},[o,r,e,t]),a}function xn(e){return G("recoil_memory_managament_2020")&&kn(e),{TRANSITION_SUPPORT:gn,SYNC_EXTERNAL_STORE:hc()?gc:gn,MUTABLE_SOURCE:bc,LEGACY:Tc}[je().mode](e)}function lr(e){let t=me(),n=xn(e);return Pn(n,e,t)}function jt(e){let t=me();return ue(n=>{Ct(t.current,e,n)},[t,e])}function Ec(e){let t=me();return ue(()=>{Ct(t.current,e,sr)},[t,e])}function wc(e){return[lr(e),jt(e)]}function Nc(e){return[xn(e),jt(e)]}function Ac(){let e=me();return(t,n={})=>{fc(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>Rc(e.current,new yn(r),o))})}}function ur(e){return G("recoil_memory_managament_2020")&&kn(e),gn(e)}function dr(e){let t=me(),n=ur(e);return Pn(n,e,t)}function Vc(e){return[dr(e),jt(e)]}var Lc={recoilComponentGetRecoilValueCount_FOR_TESTING:yc,useRecoilInterface:mc,useRecoilState:wc,useRecoilStateLoadable:Nc,useRecoilValue:lr,useRecoilValueLoadable:xn,useResetRecoilState:Ec,useSetRecoilState:jt,useSetUnvalidatedAtomValues:Ac,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:ur,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:dr,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Vc};function Cc(e,t){let n=new Map;for(let[o,r]of e)t(r,o)&&n.set(o,r);return n}var $c=Cc;function Ic(e,t){let n=new Set;for(let o of e)t(o)&&n.add(o);return n}var Uc=Ic;function Mc(...e){let t=new Map;for(let n=0;n<e.length;n++){let o=e[n].keys(),r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var Dc=Mc,{batchUpdates:Oc}=Wt,{DEFAULT_VALUE:kc,getNode:fr,nodes:Bc}=de,{useStoreRef:Fn}=be,{AbstractRecoilValue:Pc,setRecoilValueLoadable:xc}=Se,{SUSPENSE_TIMEOUT_MS:Fc}=Ie,{cloneSnapshot:$t}=Kt,{useCallback:Zt,useEffect:hr,useRef:co,useState:zc}=H.default,{isSSR:lo}=Gt;function Yt(e){let t=Fn();hr(()=>t.current.subscribeToTransactions(e).release,[e,t])}function uo(e){let t=e.atomValues.toMap(),n=Vt($c(t,(o,r)=>{let i=fr(r).persistence_UNSTABLE;return i!=null&&i.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return Dc(e.nonvalidatedAtoms.toMap(),n)}function Wc(e){Yt(Zt(t=>{let n=t.getState().previousTree,o=t.getState().currentTree;n||(se("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);let r=uo(o),a=uo(n),i=Vt(Bc,u=>{var f,_,v,C;return{persistence_UNSTABLE:{type:(f=(_=u.persistence_UNSTABLE)===null||_===void 0?void 0:_.type)!==null&&f!==void 0?f:"none",backButton:(v=(C=u.persistence_UNSTABLE)===null||C===void 0?void 0:C.backButton)!==null&&v!==void 0?v:!1}}}),l=Uc(o.dirtyAtoms,u=>r.has(u)||a.has(u));e({atomValues:r,previousAtomValues:a,atomInfo:i,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))}function Gc(e){Yt(Zt(t=>{let n=$t(t,"latest"),o=$t(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function Hc(){let e=Fn(),[t,n]=zc(()=>$t(e.current)),o=ir(t),r=co(),a=co();if(Yt(Zt(l=>n($t(l)),[])),hr(()=>{let l=t.retain();if(r.current&&!lo){var u;window.clearTimeout(r.current),r.current=null,(u=a.current)===null||u===void 0||u.call(a),a.current=null}return()=>{window.setTimeout(l,10)}},[t]),o!==t&&!lo){if(r.current){var i;window.clearTimeout(r.current),r.current=null,(i=a.current)===null||i===void 0||i.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var l;r.current=null,(l=a.current)===null||l===void 0||l.call(a),a.current=null},Fc)}return t}function _r(e,t){var n;let o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Oc(()=>{let i=new Set;for(let f of[r.atomValues.keys(),a.atomValues.keys()])for(let _ of f){var l,u;((l=r.atomValues.get(_))===null||l===void 0?void 0:l.contents)!==((u=a.atomValues.get(_))===null||u===void 0?void 0:u.contents)&&fr(_).shouldRestoreFromSnapshots&&i.add(_)}i.forEach(f=>{xc(e,new Pc(f),a.atomValues.has(f)?Y(a.atomValues.get(f)):kc)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}function Kc(){let e=Fn();return Zt(t=>_r(e.current,t),[e])}var pr={useRecoilSnapshot:Hc,gotoSnapshot:_r,useGotoRecoilSnapshot:Kc,useRecoilTransactionObserver:Gc,useTransactionObservation_DEPRECATED:Wc,useTransactionSubscription_DEPRECATED:Yt},{peekNodeInfo:qc}=Ee,{useStoreRef:jc}=be;function Zc(){let e=jc();return({key:t})=>qc(e.current,e.current.getState().currentTree,t)}var Yc=Zc,{reactMode:Xc}=qe,{RecoilRoot:Jc,useStoreRef:Qc}=be,{useMemo:el}=H.default;function tl(){Xc().mode;let e=Qc().current;return el(()=>{function t({children:n}){return H.default.createElement(Jc,{store_INTERNAL:e},n)}return t},[e])}var nl=tl,{loadableWithValue:ol}=ut,{initializeNode:rl}=Ee,{DEFAULT_VALUE:al,getNode:il}=de,{copyTreeState:sl,getRecoilValueAsLoadable:cl,invalidateDownstreams:ll,writeLoadableToTreeState:ul}=Se;function fo(e){return il(e.key).nodeType==="atom"}var bn=class{constructor(t,n){I(this,"_store",void 0),I(this,"_treeState",void 0),I(this,"_changes",void 0),I(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!fo(o))throw U("Reading selectors within atomicUpdate is not supported");let r=cl(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:U(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),I(this,"set",(o,r)=>{if(!fo(o))throw U("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){let a=this.get(o);this._changes.set(o.key,r(a))}else rl(this._store,o.key,"set"),this._changes.set(o.key,r)}),I(this,"reset",o=>{this.set(o,al)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;let t=sl(this._treeState);for(let[n,o]of this._changes)ul(t,n,ol(o));return ll(this._store,t),t}};function dl(e){return t=>{e.replaceState(n=>{let o=new bn(e,n);return t(o),o.newTreeState_INTERNAL()})}}var fl={atomicUpdater:dl},hl=fl.atomicUpdater,vr=Object.freeze({__proto__:null,atomicUpdater:hl});function _l(e,t){if(!e)throw new Error(t)}var pl=_l,nt=pl,{atomicUpdater:vl}=vr,{batchUpdates:Rl}=Wt,{DEFAULT_VALUE:Sl}=de,{useStoreRef:ml}=be,{refreshRecoilValue:yl,setRecoilValue:ho}=Se,{cloneSnapshot:gl}=Kt,{gotoSnapshot:bl}=pr,{useCallback:Tl}=H.default,It=class{},El=new It;function Rr(e,t,n,o){let r=El,a;if(Rl(()=>{let l="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw U(l);let u=Co({...o??{},set:(_,v)=>ho(e,_,v),reset:_=>ho(e,_,Sl),refresh:_=>yl(e,_),gotoSnapshot:_=>bl(e,_),transact_UNSTABLE:_=>vl(e)(_)},{snapshot:()=>{let _=gl(e);return a=_.retain(),_}}),f=t(u);if(typeof f!="function")throw U(l);r=f(...n)}),r instanceof It&&nt(!1),Z(r))r.finally(()=>{var l;(l=a)===null||l===void 0||l()});else{var i;(i=a)===null||i===void 0||i()}return r}function wl(e,t){let n=ml();return Tl((...o)=>Rr(n.current,e,o),t!=null?[...t,n]:void 0)}var Sr={recoilCallback:Rr,useRecoilCallback:wl},{useStoreRef:Nl}=be,{refreshRecoilValue:Al}=Se,{useCallback:Vl}=H.default;function Ll(e){let t=Nl();return Vl(()=>{let n=t.current;Al(n,e)},[e,t])}var Cl=Ll,{atomicUpdater:$l}=vr,{useStoreRef:Il}=be,{useMemo:Ul}=H.default;function Ml(e,t){let n=Il();return Ul(()=>(...o)=>{$l(n.current)(a=>{e(a)(...o)})},t!=null?[...t,n]:void 0)}var Dl=Ml,Tn=class{constructor(t){I(this,"value",void 0),this.value=t}},Ol={WrappedValue:Tn},kl=Ol.WrappedValue,mr=Object.freeze({__proto__:null,WrappedValue:kl}),{isFastRefreshEnabled:Bl}=qe,Ut=class extends Error{},En=class{constructor(t){var n,o,r;I(this,"_name",void 0),I(this,"_numLeafs",void 0),I(this,"_root",void 0),I(this,"_onHit",void 0),I(this,"_onSet",void 0),I(this,"_mapNodeValue",void 0),this._name=t?.name,this._numLeafs=0,this._root=null,this._onHit=(n=t?.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t?.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t?.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n?.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;let r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){let r=()=>{var a,i,l,u;let f,_;for(let[X,ne]of t){var v,C,L;let E=this._root;if(E?.type==="leaf")throw this.invalidCacheError();let B=f;if(f=B?B.branches.get(_):E,f=(v=f)!==null&&v!==void 0?v:{type:"branch",nodeKey:X,parent:B,branches:new Map,branchKey:_},f.type!=="branch"||f.nodeKey!==X)throw this.invalidCacheError();B?.branches.set(_,f),o==null||(C=o.onNodeVisit)===null||C===void 0||C.call(o,f),_=this._mapNodeValue(ne),this._root=(L=this._root)!==null&&L!==void 0?L:f}let y=f?(a=f)===null||a===void 0?void 0:a.branches.get(_):this._root;if(y!=null&&(y.type!=="leaf"||y.branchKey!==_))throw this.invalidCacheError();let w={type:"leaf",value:n,parent:f,branchKey:_};(i=f)===null||i===void 0||i.branches.set(_,w),this._root=(l=this._root)!==null&&l!==void 0?l:w,this._numLeafs++,this._onSet(w),o==null||(u=o.onNodeVisit)===null||u===void 0||u.call(o,w)};try{r()}catch(a){if(a instanceof Ut)this.clear(),r();else throw a}}delete(t){let n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){let t=Bl()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw se(t+(this._name!=null?` - ${this._name}`:"")),new Ut}},Pl={TreeCache:En},xl=Pl.TreeCache,yr=Object.freeze({__proto__:null,TreeCache:xl}),wn=class{constructor(t){var n;I(this,"_maxSize",void 0),I(this,"_size",void 0),I(this,"_head",void 0),I(this,"_tail",void 0),I(this,"_map",void 0),I(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){let n=this._keyMapper(t),o=this._map.get(n);if(!!o)return this.set(t,o.value),o.value}set(t,n){let o=this._keyMapper(t);this._map.get(o)&&this.delete(t);let a=this.head(),i={key:t,right:a,left:null,value:n};a?a.left=i:this._tail=i,this._map.set(o,i),this._head=i,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){let t=this.tail();t&&this.delete(t.key)}delete(t){let n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;let o=Y(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Fl={LRUCache:wn},zl=Fl.LRUCache,gr=Object.freeze({__proto__:null,LRUCache:zl}),{LRUCache:Wl}=gr,{TreeCache:Gl}=yr;function Hl({name:e,maxSize:t,mapNodeValue:n=o=>o}){let o=new Wl({maxSize:t}),r=new Gl({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{let i=o.tail();o.set(a,!0),i&&r.size()>t&&r.delete(i.key)}});return r}var _o=Hl;function Re(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(t?.allowFunctions!==!0)throw U("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(Z(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>Re(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return Re(e.toJSON(n),t,n);if(e instanceof Map){let r={};for(let[a,i]of e)r[typeof a=="string"?a:Re(a,t)]=i;return Re(r,t,n)}return e instanceof Set?Re(Array.from(e).sort((r,a)=>Re(r,t).localeCompare(Re(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?Re(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${Re(r,t)}:${Re(e[r],t,r)}`).join(",")}}`}function Kl(e,t={allowFunctions:!1}){return Re(e,t)}var Xt=Kl,{TreeCache:ql}=yr,vt={equality:"reference",eviction:"keep-all",maxSize:1/0};function jl({equality:e=vt.equality,eviction:t=vt.eviction,maxSize:n=vt.maxSize}=vt,o){let r=Zl(e);return Yl(t,n,r,o)}function Zl(e){switch(e){case"reference":return t=>t;case"value":return t=>Xt(t)}throw U(`Unrecognized equality policy ${e}`)}function Yl(e,t,n,o){switch(e){case"keep-all":return new ql({name:o,mapNodeValue:n});case"lru":return _o({name:o,maxSize:Y(t),mapNodeValue:n});case"most-recent":return _o({name:o,maxSize:1,mapNodeValue:n})}throw U(`Unrecognized eviction policy ${e}`)}var Xl=jl;var{isReactNative:Nd,isWindow:Ad}=Gt;function Jl(e){return()=>null}var Ql={startPerfBlock:Jl},{isLoadable:eu,loadableWithError:Rt,loadableWithPromise:tu,loadableWithValue:ln}=ut,{WrappedValue:br}=mr,{getNodeLoadable:St,peekNodeLoadable:nu,setNodeValue:ou}=Ee,{saveDepsToStore:ru}=dt,{DEFAULT_VALUE:au,getConfigDeletionHandler:iu,getNode:su,registerNode:po}=de,{isRecoilValue:cu}=Le,{markRecoilValueModified:vo}=Se,{retainedByOptionWithDefault:lu}=Ie,{recoilCallback:uu}=Sr,{startPerfBlock:du}=Ql,Mt=class{},Qe=new Mt,et=[],mt=new Map,fu=(()=>{let e=0;return()=>e++})();function Tr(e){let t=null,{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,i=new Set,l=Xl(r??{equality:"reference",eviction:"keep-all"},n),u=lu(e.retainedBy_UNSTABLE),f=new Map,_=0;function v(){return!G("recoil_memory_managament_2020")||_>0}function C(d){return d.getState().knownSelectors.add(n),_++,()=>{_--}}function L(){return iu(n)!==void 0&&!v()}function y(d,p,R,$,b){Me(p,$,b),w(d,R)}function w(d,p){fe(d,p)&&re(d),ne(p,!0)}function X(d,p){fe(d,p)&&(Y(F(d)).stateVersions.clear(),ne(p,!1))}function ne(d,p){let R=mt.get(d);if(R!=null){for(let $ of R)vo($,Y(t));p&&mt.delete(d)}}function E(d,p){let R=mt.get(p);R==null&&mt.set(p,R=new Set),R.add(d)}function B(d,p,R,$,b,O){return p.then(k=>{if(!v())throw re(d),Qe;let T=ln(k);return y(d,R,b,T,$),k}).catch(k=>{if(!v())throw re(d),Qe;if(Z(k))return J(d,k,R,$,b,O);let T=Rt(k);throw y(d,R,b,T,$),k})}function J(d,p,R,$,b,O){return p.then(k=>{if(!v())throw re(d),Qe;O.loadingDepKey!=null&&O.loadingDepPromise===p?R.atomValues.set(O.loadingDepKey,ln(k)):d.getState().knownSelectors.forEach(W=>{R.atomValues.delete(W)});let T=Q(d,R);if(T&&T.state!=="loading"){if((fe(d,b)||F(d)==null)&&w(d,b),T.state==="hasValue")return T.contents;throw T.contents}if(!fe(d,b)){let W=ye(d,R);if(W!=null)return W.loadingLoadable.contents}let[te,ee]=K(d,R,b);if(te.state!=="loading"&&y(d,R,b,te,ee),te.state==="hasError")throw te.contents;return te.contents}).catch(k=>{if(k instanceof Mt)throw Qe;if(!v())throw re(d),Qe;let T=Rt(k);throw y(d,R,b,T,$),k})}function z(d,p,R,$){var b,O,k,T;if(fe(d,$)||p.version===((b=d.getState())===null||b===void 0||(O=b.currentTree)===null||O===void 0?void 0:O.version)||p.version===((k=d.getState())===null||k===void 0||(T=k.nextTree)===null||T===void 0?void 0:T.version)){var te,ee,W;ru(n,R,d,(te=(ee=d.getState())===null||ee===void 0||(W=ee.nextTree)===null||W===void 0?void 0:W.version)!==null&&te!==void 0?te:d.getState().currentTree.version)}for(let q of R)i.add(q)}function K(d,p,R){let $=du(n),b=!0,O=!0,k=()=>{$(),O=!1},T,te=!1,ee,W={loadingDepKey:null,loadingDepPromise:null},q=new Map;function he({key:ie}){let _e=St(d,p,ie);switch(q.set(ie,_e),b||(z(d,p,new Set(q.keys()),R),X(d,R)),_e.state){case"hasValue":return _e.contents;case"hasError":throw _e.contents;case"loading":throw W.loadingDepKey=ie,W.loadingDepPromise=_e.contents,_e.contents}throw U("Invalid Loadable state")}let ke=ie=>(..._e)=>{if(O)throw U("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&nt(!1),uu(d,ie,_e,{node:t})};try{T=o({get:he,getCallback:ke}),T=cu(T)?he(T):T,eu(T)&&(T.state==="hasError"&&(te=!0),T=T.contents),Z(T)?T=B(d,T,p,q,R,W).finally(k):k(),T=T instanceof br?T.value:T}catch(ie){T=ie,Z(T)?T=J(d,T,p,q,R,W).finally(k):(te=!0,k())}return te?ee=Rt(T):Z(T)?ee=tu(T):ee=ln(T),b=!1,Ne(d,R,q),z(d,p,new Set(q.keys()),R),[ee,q]}function Q(d,p){let R=p.atomValues.get(n);if(R!=null)return R;let $=new Set;try{R=l.get(O=>(typeof O!="string"&&nt(!1),St(d,p,O).contents),{onNodeVisit:O=>{O.type==="branch"&&O.nodeKey!==n&&$.add(O.nodeKey)}})}catch(O){throw U(`Problem with cache lookup for selector "${n}": ${O.message}`)}if(R){var b;p.atomValues.set(n,R),z(d,p,$,(b=F(d))===null||b===void 0?void 0:b.executionID)}return R}function ce(d,p){let R=Q(d,p);if(R!=null)return re(d),R;let $=ye(d,p);if($!=null){var b;return((b=$.loadingLoadable)===null||b===void 0?void 0:b.state)==="loading"&&E(d,$.executionID),$.loadingLoadable}let O=fu(),[k,T]=K(d,p,O);return k.state==="loading"?(ae(d,O,k,T,p),E(d,O)):(re(d),Me(p,k,T)),k}function ye(d,p){let R=qo([f.has(d)?[Y(f.get(d))]:[],Pt(In(f,([b])=>b!==d),([,b])=>b)]);function $(b){for(let[O,k]of b)if(!St(d,p,O).is(k))return!0;return!1}for(let b of R){if(b.stateVersions.get(p.version)||!$(b.depValuesDiscoveredSoFarDuringAsyncWork))return b.stateVersions.set(p.version,!0),b;b.stateVersions.set(p.version,!1)}}function F(d){return f.get(d)}function ae(d,p,R,$,b){f.set(d,{depValuesDiscoveredSoFarDuringAsyncWork:$,executionID:p,loadingLoadable:R,stateVersions:new Map([[b.version,!0]])})}function Ne(d,p,R){if(fe(d,p)){let $=F(d);$!=null&&($.depValuesDiscoveredSoFarDuringAsyncWork=R)}}function re(d){f.delete(d)}function fe(d,p){var R;return p===((R=F(d))===null||R===void 0?void 0:R.executionID)}function Ue(d){return Array.from(d.entries()).map(([p,R])=>[p,R.contents])}function Me(d,p,R){d.atomValues.set(n,p);try{l.set(Ue(R),p)}catch($){throw U(`Problem with setting cache for selector "${n}": ${$.message}`)}}function ge(d){if(et.includes(n)){let p=`Recoil selector has circular dependencies: ${et.slice(et.indexOf(n)).join(" \u2192 ")}`;return Rt(U(p))}et.push(n);try{return d()}finally{et.pop()}}function De(d,p){let R=p.atomValues.get(n);return R??l.get($=>{var b;return typeof $!="string"&&nt(!1),(b=nu(d,p,$))===null||b===void 0?void 0:b.contents})}function Oe(d,p){return ge(()=>ce(d,p))}function P(d){d.atomValues.delete(n)}function x(d,p){t==null&&nt(!1);for(let $ of i){var R;let b=su($);(R=b.clearCache)===null||R===void 0||R.call(b,d,p)}i.clear(),P(p),l.clear(),vo(d,t)}return a!=null?t=po({key:n,nodeType:"selector",peek:De,get:Oe,set:(p,R,$)=>{let b=!1,O=new Map;function k({key:W}){if(b)throw U("Recoil: Async selector sets are not currently supported.");let q=St(p,R,W);if(q.state==="hasValue")return q.contents;if(q.state==="loading"){let he=`Getting value of asynchronous atom or selector "${W}" in a pending state while setting selector "${n}" is not yet supported.`;throw se(he),U(he)}else throw q.contents}function T(W,q){if(b){let ie="Recoil: Async selector sets are not currently supported.";throw se(ie),U(ie)}let he=typeof q=="function"?q(k(W)):q;ou(p,R,W.key,he).forEach((ie,_e)=>O.set(_e,ie))}function te(W){T(W,au)}let ee=a({set:T,get:k,reset:te},$);if(ee!==void 0)throw Z(ee)?U("Recoil: Async selector sets are not currently supported."):U("Recoil: selector set should be a void function.");return b=!0,O},init:C,invalidate:P,clearCache:x,shouldDeleteConfigOnRelease:L,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u}):t=po({key:n,nodeType:"selector",peek:De,get:Oe,init:C,invalidate:P,clearCache:x,shouldDeleteConfigOnRelease:L,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}Tr.value=e=>new br(e);var Ke=Tr,{isLoadable:hu,loadableWithError:un,loadableWithPromise:dn,loadableWithValue:Pe}=ut,{WrappedValue:Er}=mr,{peekNodeInfo:_u}=Ee,{DEFAULT_VALUE:Ae,DefaultValue:Te,getConfigDeletionHandler:wr,registerNode:pu,setConfigDeletionHandler:vu}=de,{isRecoilValue:Ru}=Le,{getRecoilValueAsLoadable:Su,markRecoilValueModified:mu,setRecoilValue:Ro,setRecoilValueLoadable:yu}=Se,{retainedByOptionWithDefault:gu}=Ie,tt=e=>e instanceof Er?e.value:e;function bu(e){let{key:t,persistence_UNSTABLE:n}=e,o=gu(e.retainedBy_UNSTABLE),r=0;function a(E){return dn(E.then(B=>(i=Pe(B),B)).catch(B=>{throw i=un(B),B}))}let i=Z(e.default)?a(e.default):hu(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:Pe(tt(e.default));i.contents;let l,u=new Map;function f(E){return E}function _(E,B){let J=B.then(z=>{var K,Q;return((Q=((K=E.getState().nextTree)!==null&&K!==void 0?K:E.getState().currentTree).atomValues.get(t))===null||Q===void 0?void 0:Q.contents)===J&&Ro(E,ne,z),z}).catch(z=>{var K,Q;throw((Q=((K=E.getState().nextTree)!==null&&K!==void 0?K:E.getState().currentTree).atomValues.get(t))===null||Q===void 0?void 0:Q.contents)===J&&yu(E,ne,un(z)),z});return J}function v(E,B,J){var z;r++;let K=()=>{var F;r--,(F=u.get(E))===null||F===void 0||F.forEach(ae=>ae()),u.delete(E)};if(E.getState().knownAtoms.add(t),i.state==="loading"){let F=()=>{var ae;((ae=E.getState().nextTree)!==null&&ae!==void 0?ae:E.getState().currentTree).atomValues.has(t)||mu(E,ne)};i.contents.finally(F)}let Q=(z=e.effects)!==null&&z!==void 0?z:e.effects_UNSTABLE;if(Q!=null){let fe=function(P){if(ae&&P.key===t){let x=F;return x instanceof Te?C(E,B):Z(x)?dn(x.then(d=>d instanceof Te?i.toPromise():d)):Pe(x)}return Su(E,P)},Ue=function(P){return fe(P).toPromise()},Me=function(P){var x;let d=_u(E,(x=E.getState().nextTree)!==null&&x!==void 0?x:E.getState().currentTree,P.key);return ae&&P.key===t&&!(F instanceof Te)?{...d,isSet:!0,loadable:fe(P)}:d},F=Ae,ae=!0,Ne=!1,re=null,ge=P=>x=>{if(ae){let d=fe(ne),p=d.state==="hasValue"?d.contents:Ae;F=typeof x=="function"?x(p):x,Z(F)&&(F=F.then(R=>(re={effect:P,value:R},R)))}else{if(Z(x))throw U("Setting atoms to async values is not implemented.");typeof x!="function"&&(re={effect:P,value:tt(x)}),Ro(E,ne,typeof x=="function"?d=>{let p=tt(x(d));return re={effect:P,value:p},p}:tt(x))}},De=P=>()=>ge(P)(Ae),Oe=P=>x=>{var d;let{release:p}=E.subscribeToTransactions(R=>{var $;let{currentTree:b,previousTree:O}=R.getState();O||(se("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),O=b);let k=($=b.atomValues.get(t))!==null&&$!==void 0?$:i;if(k.state==="hasValue"){var T,te,ee,W;let q=k.contents,he=(T=O.atomValues.get(t))!==null&&T!==void 0?T:i,ke=he.state==="hasValue"?he.contents:Ae;((te=re)===null||te===void 0?void 0:te.effect)!==P||((ee=re)===null||ee===void 0?void 0:ee.value)!==q?x(q,ke,!b.atomValues.has(t)):((W=re)===null||W===void 0?void 0:W.effect)===P&&(re=null)}},t);u.set(E,[...(d=u.get(E))!==null&&d!==void 0?d:[],p])};for(let P of Q)try{let x=P({node:ne,storeID:E.storeID,parentStoreID_UNSTABLE:E.parentStoreID,trigger:J,setSelf:ge(P),resetSelf:De(P),onSet:Oe(P),getPromise:Ue,getLoadable:fe,getInfo_UNSTABLE:Me});if(x!=null){var ce;u.set(E,[...(ce=u.get(E))!==null&&ce!==void 0?ce:[],x])}}catch(x){F=x,Ne=!0}if(ae=!1,!(F instanceof Te)){var ye;let P=Ne?un(F):Z(F)?dn(_(E,F)):Pe(tt(F));P.contents,B.atomValues.set(t,P),(ye=E.getState().nextTree)===null||ye===void 0||ye.atomValues.set(t,P)}}return K}function C(E,B){var J,z;return(J=(z=B.atomValues.get(t))!==null&&z!==void 0?z:l)!==null&&J!==void 0?J:i}function L(E,B){if(B.atomValues.has(t))return Y(B.atomValues.get(t));if(B.nonvalidatedAtoms.has(t)){if(l!=null)return l;if(n==null)return Ln(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),i;let J=B.nonvalidatedAtoms.get(t),z=n.validator(J,Ae);return l=z instanceof Te?i:Pe(z),l}else return i}function y(){l=void 0}function w(E,B,J){if(B.atomValues.has(t)){let z=Y(B.atomValues.get(t));if(z.state==="hasValue"&&J===z.contents)return new Map}else if(!B.nonvalidatedAtoms.has(t)&&J instanceof Te)return new Map;return l=void 0,new Map().set(t,Pe(J))}function X(){return wr(t)!==void 0&&r<=0}let ne=pu({key:t,nodeType:"atom",peek:C,get:L,set:w,init:v,invalidate:y,shouldDeleteConfigOnRelease:X,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return ne}function zn(e){let{...t}=e,n="default"in e?e.default:new Promise(()=>{});return Ru(n)?Tu({...t,default:n}):bu({...t,default:n})}function Tu(e){let t=zn({...e,default:Ae,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof Te?o:Y(e.persistence_UNSTABLE).validator(o,Ae)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=Ke({key:`${e.key}__withFallback`,get:({get:o})=>{let r=o(t);return r instanceof Te?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return vu(n.key,wr(e.key)),n}zn.value=e=>new Er(e);var Nr=zn,Nn=class{constructor(t){var n;I(this,"_map",void 0),I(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t?.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}},Eu={MapCache:Nn},wu=Eu.MapCache,Nu=Object.freeze({__proto__:null,MapCache:wu}),{LRUCache:So}=gr,{MapCache:Au}=Nu,yt={equality:"reference",eviction:"none",maxSize:1/0};function Vu({equality:e=yt.equality,eviction:t=yt.eviction,maxSize:n=yt.maxSize}=yt){let o=Lu(e);return Cu(t,n,o)}function Lu(e){switch(e){case"reference":return t=>t;case"value":return t=>Xt(t)}throw U(`Unrecognized equality policy ${e}`)}function Cu(e,t,n){switch(e){case"keep-all":return new Au({mapKey:n});case"lru":return new So({mapKey:n,maxSize:Y(t)});case"most-recent":return new So({mapKey:n,maxSize:1})}throw U(`Unrecognized eviction policy ${e}`)}var Ar=Vu,{setConfigDeletionHandler:$u}=de;function Iu(e){var t,n;let o=Ar({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a,i;let l=o.get(r);if(l!=null)return l;let{cachePolicyForParams_UNSTABLE:u,...f}=e,_="default"in e?e.default:new Promise(()=>{}),v=Nr({...f,key:`${e.key}__${(a=Xt(r))!==null&&a!==void 0?a:"void"}`,default:typeof _=="function"?_(r):_,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,effects:typeof e.effects=="function"?e.effects(r):typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(r):(i=e.effects)!==null&&i!==void 0?i:e.effects_UNSTABLE});return o.set(r,v),$u(v.key,()=>{o.delete(r)}),v}}var Uu=Iu,{setConfigDeletionHandler:Mu}=de,Du=0;function Ou(e){var t,n;let o=Ar({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let i;try{i=o.get(r)}catch(C){throw U(`Problem with cache lookup for selector ${e.key}: ${C.message}`)}if(i!=null)return i;let l=`${e.key}__selectorFamily/${(a=Xt(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${Du++}`,u=C=>e.get(r)(C),f=e.cachePolicy_UNSTABLE,_=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,v;if(e.set!=null){let C=e.set;v=Ke({key:l,get:u,set:(y,w)=>C(r)(y,w),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:_})}else v=Ke({key:l,get:u,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:_});return o.set(r,v),Mu(v.key,()=>{o.delete(r)}),v}}var we=Ou,ku=we({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Bu(e){return ku(e)}var Pu=Bu,xu=we({key:"__error",get:e=>()=>{throw U(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Fu(e){return xu(e)}var zu=Fu;function Wu(e){return e}var Gu=Wu,{loadableWithError:Vr,loadableWithPromise:Lr,loadableWithValue:Cr}=ut;function Jt(e,t){let n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(let[r,a]of t.entries())try{n[r]=e(a)}catch(i){o[r]=i}return[n,o]}function Hu(e){return e!=null&&!Z(e)}function Qt(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function An(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function xe(e,t,n){let o=n.map((r,a)=>r==null?Cr(t[a]):Z(r)?Lr(r):Vr(r));return An(e,o)}function Ku(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}var qu=we({key:"__waitForNone",get:e=>({get:t})=>{let n=Qt(e),[o,r]=Jt(t,n);return xe(e,o,r)},dangerouslyAllowMutability:!0}),ju=we({key:"__waitForAny",get:e=>({get:t})=>{let n=Qt(e),[o,r]=Jt(t,n);return r.some(a=>!Z(a))?xe(e,o,r):new Promise(a=>{for(let[i,l]of r.entries())Z(l)&&l.then(u=>{o[i]=u,r[i]=void 0,a(xe(e,o,r))}).catch(u=>{r[i]=u,a(xe(e,o,r))})})},dangerouslyAllowMutability:!0}),Zu=we({key:"__waitForAll",get:e=>({get:t})=>{let n=Qt(e),[o,r]=Jt(t,n);if(r.every(i=>i==null))return An(e,o);let a=r.find(Hu);if(a!=null)throw a;return Promise.all(r).then(i=>An(e,Ku(o,i)))},dangerouslyAllowMutability:!0}),Yu=we({key:"__waitForAllSettled",get:e=>({get:t})=>{let n=Qt(e),[o,r]=Jt(t,n);return r.every(a=>!Z(a))?xe(e,o,r):Promise.all(r.map((a,i)=>Z(a)?a.then(l=>{o[i]=l,r[i]=void 0}).catch(l=>{o[i]=void 0,r[i]=l}):null)).then(()=>xe(e,o,r))},dangerouslyAllowMutability:!0}),Xu=we({key:"__noWait",get:e=>({get:t})=>{try{return Ke.value(Cr(t(e)))}catch(n){return Ke.value(Z(n)?Lr(n):Vr(n))}},dangerouslyAllowMutability:!0}),Ju={waitForNone:qu,waitForAny:ju,waitForAll:Zu,waitForAllSettled:Yu,noWait:Xu},{RecoilLoadable:Qu}=ut,{DefaultValue:ed}=de,{RecoilRoot:td,useRecoilStoreID:nd}=be,{isRecoilValue:od}=Le,{retentionZone:rd}=Ft,{freshSnapshot:ad}=Kt,{useRecoilState:id,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:sd,useRecoilStateLoadable:cd,useRecoilValue:ld,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:ud,useRecoilValueLoadable:dd,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:fd,useResetRecoilState:hd,useSetRecoilState:_d}=Lc,{useGotoRecoilSnapshot:pd,useRecoilSnapshot:vd,useRecoilTransactionObserver:Rd}=pr,{useRecoilCallback:Sd}=Sr,{noWait:md,waitForAll:yd,waitForAllSettled:gd,waitForAny:bd,waitForNone:Td}=Ju,D={DefaultValue:ed,isRecoilValue:od,RecoilLoadable:Qu,RecoilEnv:Eo,RecoilRoot:td,useRecoilStoreID:nd,useRecoilBridgeAcrossReactRoots_UNSTABLE:nl,atom:Nr,selector:Ke,atomFamily:Uu,selectorFamily:we,constSelector:Pu,errorSelector:zu,readOnlySelector:Gu,noWait:md,waitForNone:Td,waitForAny:bd,waitForAll:yd,waitForAllSettled:gd,useRecoilValue:ld,useRecoilValueLoadable:dd,useRecoilState:id,useRecoilStateLoadable:cd,useSetRecoilState:_d,useResetRecoilState:hd,useGetRecoilValueInfo_UNSTABLE:Yc,useRecoilRefresher_UNSTABLE:Cl,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:fd,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:ud,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:sd,useRecoilCallback:Sd,useRecoilTransaction_UNSTABLE:Dl,useGotoRecoilSnapshot:pd,useRecoilSnapshot:vd,useRecoilTransactionObserver_UNSTABLE:Rd,snapshot_UNSTABLE:ad,useRetain:kn,retentionZone:rd},Vd=D.DefaultValue,Ld=D.isRecoilValue,Cd=D.RecoilLoadable,$d=D.RecoilEnv,Id=D.RecoilRoot,Ud=D.useRecoilStoreID,Md=D.useRecoilBridgeAcrossReactRoots_UNSTABLE,Wn=D.atom,Dd=D.selector,Od=D.atomFamily,kd=D.selectorFamily,Bd=D.constSelector,Pd=D.errorSelector,xd=D.readOnlySelector,Fd=D.noWait,zd=D.waitForNone,Wd=D.waitForAny,Gd=D.waitForAll,Hd=D.waitForAllSettled,Kd=D.useRecoilValue,qd=D.useRecoilValueLoadable,jd=D.useRecoilState,Zd=D.useRecoilStateLoadable,Yd=D.useSetRecoilState,Xd=D.useResetRecoilState,Jd=D.useGetRecoilValueInfo_UNSTABLE,Qd=D.useRecoilRefresher_UNSTABLE,ef=D.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,tf=D.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,nf=D.useRecoilState_TRANSITION_SUPPORT_UNSTABLE,of=D.useRecoilCallback,rf=D.useRecoilTransaction_UNSTABLE,af=D.useGotoRecoilSnapshot,sf=D.useRecoilSnapshot,cf=D.useRecoilTransactionObserver_UNSTABLE,lf=D.snapshot_UNSTABLE,uf=D.useRetain,df=D.retentionZone;var $r=()=>(typeof window!="undefined"?window.location.host:"")==="mail.google.com"?"gmail":"normal";var vf=Wn({key:"AppState",default:{env:$r(),open:!1,loading:!1}}),Rf=Wn({key:"AppSettingsState",default:{}});export{Id as a,Wn as b,Dd as c,Kd as d,jd as e,Yd as f,$r as g,vf as h,Rf as i};
