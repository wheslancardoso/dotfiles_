{"version":3,"sources":["components/highlightLabel.js","components/tabItemView.js","components/TabTreeView.js","util/TabTreeNode.js","util/tabSequenceHelper.js","util/googleSuggestHelper.js","components/tabTree.js","util/TabTreeGenerator.js","util/bookmarksTreeGenerator.js","util/initializer.js","index.js"],"names":["HighlightLabel","segment","key","react_default","a","createElement","className","this","props","keyword","trim","genNormalString","children","getKey","index","value","regex","RegExp","matchedKeyword","exec","segments","split","ret","length","push","i","genKeywordString","substring","e","React","Component","TabItemIcon","tab","status","LoadingOutlined","favIconUrl","width","src","alt","isBookmark","StarTwoTone","theme","twoToneColor","isGoogleSearch","SearchOutlined","type","FolderOutlined","TabItemTitle","active","title","highlightLabel_HighlightLabel","TabItemUrl","url","TabItemControl","show","es_button","size","onClick","onClosedButtonClick","TreeParentSideLine","sytle","minHeight","height","style","TabItemView","_React$Component6","Object","inherits","_super6","tabItemView_createSuper","_this","classCallCheck","call","onSelected","selected","onTabItemSelected","selfRef","current","getBoundingClientRect","updateSidelineLength","node","setState","sideLineHeight","getSidelineHeight","selectedTabId","id","createRef","state","createClass","tabItemView_TreeParentSideLine","itemHeight","directChildrenCount","allChildrenCount","getAllChildrenCount","lastBranchChildrenCount","count","_this2","ref","onContainerClick","tabItemView_TabItemIcon","tabItemView_TabItemControl","tabItemView_TabItemTitle","tabItemView_TabItemUrl","getChildren","SearchItemView","_TabItemView","_super7","apply","arguments","_this3","TabTreeView","_super","rect","selfRect","bottom","scrollTop","top","tNode","map","child","renderTabTreeNode","ItemView","renderChildren","rootNode","TabTreeNode","undefined","parent","parentId","tabIds","forEach","concat","getAllTabIds","tabId","findChildById","setTitle","setFavIconUrl","setStatus","TabSequenceHelper","bookmarkRootNode","googleSearchNode","dfs","tabList","refreshQueue","currentIdx","activeTab","getNodeByTabId","GoogleSuggestHelper","genGoogleSuggestRootNode","_callee","query","regenerator_default","wrap","_context","prev","next","abrupt","Promise","resolve","fetchGoogleSearchSuggestion","then","assembleRootNodeBySuggestItems","stop","_callee2","_context2","fetch","handleResponse","str","window","DOMParser","parseFromString","extractSuggestionItems","catch","handleRequestError","response","ok","Error","statusText","text","res","doc","suggestionItems","toConsumableArray","item","getAttribute","items","root","tabTreeNode","getUniqueId","MAX_SHOW_BOOKMARK_COUNT","TabTree","onKeyDown","focusNextTabItem","focusPrevTabItem","searchInputInComposition","selectedTab","altKeyDown","searchFieldRef","blur","focusSearchField","onCloseAllTabs","onKeyUp","getNextTab","getPreviousTab","focus","blurSearchField","refreshRootNode","asyncToGenerator","mark","_args","initializer","getTree","sent","getActiveTab","t0","getBookmarks","t1","t2","getTopNBookMarks","selectGoogleSearchInference","maxCount","slice","updateTabSequence","googleSuggestRootNode","setCurrentIdx","onTabUpdate","changeInfo","setTitleById","setFavIconUrlById","setStatusById","onTabRemoved","removeInfo","chrome","tabs","remove","noTabSelected","searchByGoogle","create","update","googleSearchEnabled","googleSearchSuggestEnabled","onSearchTextChanged","normalizeString","target","searchInputCompositionStart","searchInputCompositionEnd","showSearchTip","showBookmarks","showBookmarkTitle","showGoogleSuggest","initalRootNode","onUpdated","addListener","onRemoved","initailKeyword","googleSuggestHelper","document","addEventListener","replace","inputPlaceholder","googleSearchTip","bookmarks","bookmarkTitle","TabTreeView_TabTreeView","googleSearchSuggest","input","onChange","onCompositionStart","onCompositionEnd","placeholder","TreeGenerator","tabParentMap","nodeMap","tabMap","getNode","parentNode","getParentTabId","parentTabId","currentTabMap","BookmarksTreeGenerator","results","rawTrees","copyTree","copyTreeAsFlatten","tabTreeNodeParent","bmNodes","bmNode","childTabTreeNode","createTabTreeNodeByBMNode","isFolder","filterNode","tabTreeRootNode","isLeaf","test","genBMNodeId","Initializer","filterNodes","filter","needFilterByKeyword","windowId","windows","WINDOW_ID_CURRENT","getTablist","find","runtime","getBackgroundPage","getTabParentMap","treeGen","TabTreeGenerator","getBookmarksTree","rawBookmarkTree","getFlattenTree","ReactDOM","render","tabTree_TabTree","getElementById"],"mappings":"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","file":"static/js/main.bd8b4d57.chunk.js","sourcesContent":["import React from 'react';\n\nexport default class HighlightLabel extends React.Component {\n\n    genNormalString(segment, key) {\n        return (\n            <span key={key}>{segment}</span>\n        )\n    }\n\n    genKeywordString(segment, key) {\n        return (\n            <span className=\"keyword\" key={key}>{segment}</span>\n        )\n    }\n\n    render() {\n        if (!this.props.keyword || this.props.keyword.trim() === \"\") {\n            return <div className={this.props.className}>{this.genNormalString(this.props.children)}</div>\n        }\n        const getKey = (index, value) => {\n            return index + '-' + value;\n        }\n\n        try {\n            let regex = new RegExp(this.props.keyword, \"ig\");\n            let matchedKeyword = regex.exec(this.props.children);\n            this.segments = this.props.children.split(regex);\n            let ret = [], key = 0, length = 0;\n            ret.push(this.genNormalString(this.segments[0], getKey(key++, this.segments[0])));\n            length += this.segments[0].length;\n            for (let i = 1; i < this.segments.length; i++) {\n                ret.push(this.genKeywordString(this.props.children.substring(length, length + matchedKeyword[0].length), getKey(key++, this.props.keyword)));\n                // ret.push(this.genKeywordString(matchedKeyword[0], getKey(key++, this.props.keyword)));\n                ret.push(this.genNormalString(this.segments[i], getKey(key++, this.segments[i])));\n                length += matchedKeyword[0].length; \n                length += this.segments[i].length;\n            }\n            return (\n                <div className={this.props.className}>\n                    {ret}\n                </div>\n            );\n        } catch (e) {\n            return <div className={this.props.className}>{this.genNormalString(this.props.children)}</div>\n        }\n    }\n}\n","import React from 'react';\nimport { Button } from 'antd';\nimport { FolderOutlined, StarTwoTone, LoadingOutlined, SearchOutlined} from '@ant-design/icons';\nimport HighligthLabel from './highlightLabel';\n\nclass TabItemIcon extends React.Component {\n    render() {\n        let tab = this.props.tab;\n        if (tab.status === 'loading') {\n            return (\n                <LoadingOutlined className=\"front-icon\" />\n            )\n        } else {\n            if (tab.favIconUrl) {\n                return (\n                    <img width=\"16px\" src={tab.favIconUrl} alt=\"\" />\n                );\n            } else if (tab.isBookmark) {\n                return (\n                    <StarTwoTone className=\"front-icon\" theme=\"twoTone\" twoToneColor=\"#ffbf2b\" />\n                )\n            } else if (tab.isGoogleSearch) {\n                return (\n                    <SearchOutlined type=\"search\" className=\"front-icon\" />\n                )\n            } else {\n                return (\n                    <FolderOutlined className=\"front-icon\" />\n                )\n            }\n        }\n\n        //TODO: to identify the relationship between tab's status and tab's favIconUrl\n        // if (tab.favIconUrl) {\n        //     return (\n        //         <img src={tab.favIconUrl} alt=\"\" />\n        //     );\n        // } else if (tab.status === 'loading') {\n        //     return (\n        //         <Icon type=\"loading\" className=\"front-icon\" />\n        //     )\n        // } else {\n        //     return (\n        //         <Icon type=\"folder\" className=\"front-icon\" />\n        //     )\n        // }\n    }\n}\n\nclass TabItemTitle extends React.Component {\n    //TODO: we can add keyword bold here\n    render() {\n        const className = \"title\" + (this.props.tab.active ? \" active\" : \"\");\n        if (!this.props.tab.title) {\n            return <HighligthLabel className={className}>loading...</HighligthLabel>\n        }\n        if (this.props.tab.isGoogleSearch) {\n            return <span className=\"searchItem\">{this.props.tab.title}</span>\n        }\n        return (\n            <HighligthLabel className={className} keyword={this.props.keyword}>{this.props.tab.title}</HighligthLabel>\n        )\n    }\n}\n\nclass TabItemUrl extends React.Component {\n    render() {\n        return <HighligthLabel className=\"url\" keyword={this.props.keyword}>{this.props.tab.url}</HighligthLabel>\n    }\n}\n\nclass TabItemControl extends React.Component {\n    render() {\n        if (this.props.show) {\n            return (\n                <div className=\"closeTabControl\">\n                    <span className=\"closeTabTip\"><span className=\"kbd\">Alt</span> + <span className=\"kbd\">w</span> to close Sub-Tabs</span>\n                    <span className=\"closeTabButton\">\n                        <Button className=\"kbd\" size=\"small\" onClick={this.props.onClosedButtonClick}>Close Sub-Tabs</Button>\n                    </span>\n                </div>\n            )\n        } else {\n            return null;\n        }\n    }\n}\n\nclass TreeParentSideLine extends React.Component {\n    render() {\n        let height = this.props.height + 'px';\n        const sytle = {\n            'minHeight': height,\n        };\n\n        return (\n            <div className=\"vertical-line\" style={sytle}></div>\n        )\n    }\n}\n\nexport class TabItemView extends React.Component {\n\n    constructor(props) {\n        super(props)\n        this.selfRef = React.createRef();\n        this.state = {\n            sideLineHeight: 0,\n        }\n    }\n\n    getChildren() {\n        if (this.props.children) {\n            return (\n                <div className=\"fake-ul treeParent\">\n                    <TreeParentSideLine height={this.getSidelineHeight()} />\n                    {this.props.children}\n                </div>\n            )\n        }\n        return null;\n    }\n\n    getSidelineHeight() {\n        if (this.itemHeight) {\n            var directChildrenCount = this.props.node.children.length;\n            const allChildrenCount = this.getAllChildrenCount(this.props.node);\n            const lastBranchChildrenCount = 1 + this.getAllChildrenCount(this.props.node.children[directChildrenCount - 1]);\n            const height = this.itemHeight;\n            return (allChildrenCount - lastBranchChildrenCount) * height + height / 2;\n        }\n        return 0;\n    }\n\n    getAllChildrenCount(node) {\n        if (node.children.length === 0) {\n            return 0;\n        }\n        let count = node.children.length;\n        for (let i = 0; i < node.children.length; i++) {\n            count += this.getAllChildrenCount(node.children[i]);\n        }\n        return count;\n    }\n\n    onSelected = () => {\n        if (this.selected() && this.props.onTabItemSelected) {\n            this.props.onTabItemSelected(this.selfRef.current.getBoundingClientRect())\n        }\n    }\n\n    updateSidelineLength = () => {\n        if (this.props.node.children && this.props.node.children.length > 0) {\n            this.setState({\n                sideLineHeight: this.getSidelineHeight(),\n            });\n        }\n    }\n\n    componentDidMount() {\n        this.itemHeight = this.selfRef.current.getBoundingClientRect().height;\n        this.updateSidelineLength();\n    }\n\n    componentDidUpdate() {\n        this.onSelected();\n    }\n\n    selected = () => {\n        return this.props.selectedTabId && this.props.selectedTabId === this.props.tab.id;\n    }\n\n    render() {\n        return (\n            <div className=\"fake-li\">\n                <div className={this.selected() ? \"container selected\" : \"container\"} ref={this.selfRef}>\n                    <div className=\"icon-container\" onClick={() => { this.props.onContainerClick(this.props.tab) }}>\n                        <TabItemIcon tab={this.props.tab} />\n                    </div>\n                    <TabItemControl show={!this.props.tab.isBookmark} onClosedButtonClick={() => { this.props.onClosedButtonClick(this.props.node) }} />\n                    <div className=\"content-container\" onClick={() => { this.props.onContainerClick(this.props.tab) }}>\n                        <TabItemTitle tab={this.props.tab} keyword={this.props.keyword} />\n                        <TabItemUrl tab={this.props.tab} keyword={this.props.keyword} />\n                    </div>\n                </div>\n                {this.getChildren()}\n            </div>\n        )\n    }\n}\n\nexport class SearchItemView extends TabItemView {\n    render() {\n        return (\n            <div className=\"fake-li\">\n                <div className={this.selected() ? \"container selected\" : \"container\"} ref={this.selfRef}>\n                    <div className=\"icon-container\" onClick={() => { this.props.onContainerClick(this.props.tab) }}>\n                        <TabItemIcon tab={this.props.tab} />\n                    </div>\n                    <div className=\"content-container\" onClick={() => { this.props.onContainerClick(this.props.tab) }}>\n                        <TabItemTitle tab={this.props.tab} keyword={this.props.keyword} />\n                    </div>\n                </div>\n                {this.getChildren()}\n            </div>\n        )\n    }\n}\n\n","import React from 'react';\nimport { TabItemView, SearchItemView } from './tabItemView';\n\nexport default class TabTreeView extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.selfRef = React.createRef();\n    }\n\n    renderChildren(tNode) {\n        if (tNode.children.length === 0) {\n            return null;\n        }\n        return tNode.children.map((child) => {\n            return this.renderTabTreeNode(child);\n        })\n    }\n\n    onTabItemSelected = (rect) => {\n        let selfRect = this.selfRef.current.getBoundingClientRect();\n        if (rect.bottom > selfRect.bottom) {\n            this.selfRef.current.scrollTop += (rect.bottom - selfRect.bottom);\n        } else if (rect.top < selfRect.top) {\n            this.selfRef.current.scrollTop -= (selfRect.top - rect.top);\n        }\n    }\n\n    renderTabTreeNode(tNode) {\n        const ItemView = tNode.tab.isGoogleSearch ? SearchItemView : TabItemView;\n        return  (\n            <ItemView\n                // onTabItemSelected={this.onTabItemSelected}\n                onTabItemSelected={this.props.onTabItemSelected}\n                selectedTabId={this.props.selectedTabId}\n                node={tNode}\n                key={tNode.tab.id}\n                tab={tNode.tab}\n                keyword={this.props.keyword}\n                onContainerClick={this.props.onContainerClick}\n                onClosedButtonClick={this.props.onClosedButtonClick}\n            >\n                {this.renderChildren(tNode)}\n            </ItemView>\n        );\n    }\n\n    render() {\n        return (\n            <div className=\"tabTreeView\" ref={this.selfRef}>\n                {this.renderChildren(this.props.rootNode)}\n            </div>\n        )\n    }\n}","class TabTreeNode {\n    constructor(tab = undefined, children = [], parent = undefined) {\n        this.tab = tab;\n        this.children = children;\n        this.parent = parent;\n    }\n\n    hasParent() {\n        return this.parentId !== undefined;\n    }\n\n    getParent() {\n        return this.parent;\n    }\n\n    toString() {\n        return this.tab === undefined ? \"ROOT\" : this.tab.id;\n    }\n\n    getAllTabIds() {\n        let tabIds = [this.tab.id];\n        if (this.children.length > 0) {\n            this.children.forEach((child) => {\n                tabIds = tabIds.concat(child.getAllTabIds())\n            });\n        }\n        return tabIds;\n    }\n\n    findChildById(tabId) {\n        if (this.tab !== undefined && this.tab.id === tabId) {\n            return this;\n        }\n        for (let i = 0; i < this.children.length; i++) {\n            let tab = this.children[i].findChildById(tabId);\n            if (tab !== null) {\n                return tab;\n            }\n        }\n        return null;\n    }\n\n    setTitle(title) {\n        this.tab.title = title;\n    }\n\n    setFavIconUrl(favIconUrl) {\n        this.tab.favIconUrl = favIconUrl;\n    }\n\n    setStatus(status) {\n        this.tab.status = status;\n    }\n\n    setTitleById(tabId, title) {\n        let node = this.findChildById(tabId);\n        if (node !== null) {\n            node.setTitle(title);\n        }\n    }\n\n    setFavIconUrlById(tabId, favIconUrl) {\n        let node = this.findChildById(tabId);\n        if (node !== null) {\n            node.setFavIconUrl(favIconUrl);\n        }\n    }\n\n    setStatusById(tabId, status) {\n        let node = this.findChildById(tabId);\n        if (node !== null) {\n            node.setStatus(status);\n        }\n    }\n}\n\nexport default TabTreeNode;","export default class TabSequenceHelper {\n    constructor(rootNode, bookmarkRootNode, googleSearchNode) {\n        this.refreshQueue(rootNode, bookmarkRootNode, googleSearchNode);\n    }\n\n    getNextTab() {\n        if (this.tabList.length === 0) {\n            return null;\n        }\n        this.currentIdx = (this.currentIdx + 1) % this.tabList.length;\n        return this.tabList[this.currentIdx].tab;\n    }\n\n    getPreviousTab() {\n        if (this.tabList.length === 0) {\n            return null;\n        }\n        this.currentIdx = (this.currentIdx === -1 ?  0 : this.currentIdx);\n        this.currentIdx = (this.currentIdx - 1 + this.tabList.length) % this.tabList.length;\n        return this.tabList[this.currentIdx].tab;\n    }\n\n    refreshQueue(rootNode, bookmarkRootNode, googleSearchNode) {\n        this.tabList = [];\n        this.dfs(rootNode);\n        this.dfs(bookmarkRootNode);\n        this.dfs(googleSearchNode);\n        this.currentIdx = -1;\n    }\n\n    setCurrentIdx(activeTab) {\n        for (let i = 0; i < this.tabList.length; i ++) {\n            if (this.tabList[i].tab.id === activeTab.id) {\n                this.currentIdx = i;\n            }\n        }\n    }\n\n    dfs = (node) => {\n        if (node && node.children && node.children.length > 0) {\n            for (let i = 0; i < node.children.length; i++) {\n                this.tabList.push(node.children[i]);\n                this.dfs(node.children[i]);\n            }\n        }\n    }\n\n    getNodeByTabId(tabId, node) {\n        if (node.tab && node.tab.id === tabId) {\n            return node;\n        }\n        for (var i = 0; i < node.children.length ; i ++ ) {\n            const ret = this.getNodeByTabId(tabId, node.children[i]);\n            if (ret !== null) {\n                return ret;\n            }\n        }\n        return null;\n    }\n}","import TabTreeNode from './TabTreeNode';\n\nexport default class GoogleSuggestHelper {\n\n    genGoogleSuggestRootNode = async (query) => {\n        if (!query || query.length === 0) {\n            return Promise.resolve(new TabTreeNode());\n        }\n        return this.fetchGoogleSearchSuggestion(query)\n            .then(this.assembleRootNodeBySuggestItems);\n    }\n\n    fetchGoogleSearchSuggestion = async (query) => {\n        const url = `https://suggestqueries.google.com/complete/search?output=toolbar&q=${query}`;\n        return fetch(url)\n            .then(this.handleResponse)\n            .then(str => (new window.DOMParser()).parseFromString(str, \"text/xml\"))\n            .then(this.extractSuggestionItems)\n            .catch(this.handleRequestError);\n        // return Promise.resolve(['test', 'test course', 'test basketball']);\n    }\n\n    handleResponse = (response) => {\n        if (!response.ok) {\n            throw Error(response.statusText);\n        }\n        return response.text();\n    }\n\n    handleRequestError = (res) => {\n        return [];\n    }\n\n    extractSuggestionItems = (doc) => {\n        let suggestionItems = [];\n        if (doc.children.length > 0 && doc.children[0].children.length > 0) {\n            [...doc.children[0].children].forEach((item) => suggestionItems.push(item.children[0].getAttribute('data')))\n        }\n        return suggestionItems;\n    }\n\n    assembleRootNodeBySuggestItems = (items) => {\n        const root = new TabTreeNode();\n        items.forEach((item) => {\n            let tabTreeNode = new TabTreeNode({\n                id: this.getUniqueId(item),\n                title: item,\n                url: '_____',\n                isGoogleSearch: true\n            });\n            root.children.push(tabTreeNode);\n        })\n        return root;\n    }\n\n    getUniqueId = (item) => {\n        return `gg-${item}`;\n    }\n}","import React from 'react';\nimport TabTreeView from './TabTreeView';\nimport TabTreeNode from '../util/TabTreeNode';\nimport { Input } from 'antd';\nimport TabSequenceHelper from '../util/tabSequenceHelper';\nimport GoogleSuggestHelper from '../util/googleSuggestHelper';\n\nconst MAX_SHOW_BOOKMARK_COUNT = 30;\n// const MIN_GOOGLE_SEARCH_INFER_COUNT = 3;\n// const GOOGLE_SEARCH_INFER_COUNT_NO_LIMIT = -1;\n\nexport default class TabTree extends React.Component {\n    constructor(props) {\n        super(props);\n        this.initializer = this.props.initializer;\n        const initalRootNode = new TabTreeNode();\n        const bookmarkRootNode = new TabTreeNode();\n        const googleSuggestRootNode = new TabTreeNode();\n        this.state = {\n            selectedTab: { id: -1 },\n            keyword: \"\",\n            rootNode: initalRootNode,\n            bookmarkRootNode: bookmarkRootNode,\n            googleSuggestRootNode: googleSuggestRootNode,\n        }\n        this.refreshRootNode();\n        this.props.chrome.tabs.onUpdated.addListener(this.onTabUpdate);\n        this.props.chrome.tabs.onRemoved.addListener(this.onTabRemoved);\n        this.initailKeyword = \"\";\n        this.searchFieldRef = React.createRef();\n        this.selfRef = React.createRef();\n        this.TabSequenceHelper = new TabSequenceHelper(initalRootNode, bookmarkRootNode, googleSuggestRootNode);\n        this.googleSuggestHelper = new GoogleSuggestHelper();\n        this.altKeyDown = false;\n        this.searchInputInComposition = false;\n    }\n\n    onKeyDown = (e) => {\n        // console.log(e.key);\n        if (e.key === 'ArrowDown') {\n            this.focusNextTabItem();\n        }\n\n        if (e.key === 'ArrowUp') {\n            this.focusPrevTabItem();\n        }\n\n        if (e.key === 'Enter') {\n            // block the search behavior if the searchInput is in composition such as using input method\n            if (this.searchInputInComposition === true) {\n                this.searchInputInComposition = false;\n                return;\n            }\n            this.onContainerClick(this.state.selectedTab)\n        }\n\n        if (e.key === 'Alt') {\n            this.altKeyDown = true;\n            this.searchFieldRef.current.blur();\n            return;\n        }\n        // In mac's chrome, when press Alt + w, it will trigger '∑'\n        if (this.altKeyDown && (e.key === 'w' || e.key === 'W' || e.key === '∑')) {\n            if (this.state.selectedTab.id !== -1) {\n                this.onCloseAllTabs(this.TabSequenceHelper.getNodeByTabId(this.state.selectedTab.id, this.state.rootNode))\n            }\n            return;\n        }\n        this.focusSearchField();\n    }\n\n    onKeyUp = (e) => {\n        if (e.key === 'Alt') {\n            this.altKeyDown = false;\n            this.focusSearchField();\n        }\n    }\n\n    focusNextTabItem = () => {\n        let selectedTab = this.TabSequenceHelper.getNextTab();\n        if (selectedTab) {\n            this.setState({\n                selectedTab\n            });\n        }\n    }\n\n    focusPrevTabItem = () => {\n        let selectedTab = this.TabSequenceHelper.getPreviousTab();\n        if (selectedTab) {\n            this.setState({\n                selectedTab\n            });\n        }\n    }\n\n    componentDidMount() {\n        this.focusSearchField();\n        document.addEventListener(\"keydown\", this.onKeyDown, false);\n        document.addEventListener(\"keyup\", this.onKeyUp, false);\n    }\n\n    focusSearchField = () => {\n        this.searchFieldRef.current.focus();\n    }\n\n    blurSearchField = () => {\n        this.searchFieldRef.current.blur();\n    }\n\n    refreshRootNode = async (keyword = undefined) => {\n        let rootNode = await this.initializer.getTree(keyword);\n        let activeTab = await this.initializer.getActiveTab();\n        let bookmarkRootNode = this.getTopNBookMarks(await this.initializer.getBookmarks(keyword), MAX_SHOW_BOOKMARK_COUNT);\n        // this.googleSuggestHelper.fetchGoogleSearchSuggestion(keyword).then(res => console.log(res))\n        this.setState({\n            rootNode: rootNode,\n            bookmarkRootNode: bookmarkRootNode,\n            selectedTab: keyword ? {id: -1} : activeTab,\n        })\n        // put the google search suggestion here to avoid network latency impaction towards page update.\n        // let maxInferenceCount = rootNode.children.length > 0 || bookmarkRootNode.children.length > 0 ? MIN_GOOGLE_SEARCH_INFER_COUNT : GOOGLE_SEARCH_INFER_COUNT_NO_LIMIT\n        // let googleSuggestRootNode = this.selectGoogleSearchInference(await this.googleSuggestHelper.genGoogleSuggestRootNode(keyword), maxInferenceCount);\n        // this.setState({\n        //     googleSuggestRootNode: googleSuggestRootNode\n        // })\n    }\n\n    selectGoogleSearchInference = (root, maxCount) => {\n        if (maxCount === -1) {\n            return root;\n        }\n        if (root && root.children) {\n            root.children = root.children.slice(0, maxCount)\n        }\n        return root\n    }\n\n    updateTabSequence = () => {\n        this.TabSequenceHelper.refreshQueue(this.state.rootNode, this.state.bookmarkRootNode, this.state.googleSuggestRootNode);\n        this.TabSequenceHelper.setCurrentIdx(this.state.selectedTab);\n    }\n\n    getTopNBookMarks = (bookmarkRootNode, count) => {\n        if (bookmarkRootNode.children.length > count) {\n            bookmarkRootNode.children = bookmarkRootNode.children.slice(0, count);\n        }\n        return bookmarkRootNode;\n    }\n\n    onTabUpdate = (tabId, changeInfo, tab) => {\n        let rootNode = this.state.rootNode;\n        if (changeInfo.title) {\n            rootNode.setTitleById(tabId, changeInfo.title);\n            this.setState({\n                rootNode: rootNode\n            });\n        }\n        if (changeInfo.favIconUrl) {\n            rootNode.setFavIconUrlById(tabId, changeInfo.favIconUrl);\n            this.setState({\n                rootNode: rootNode\n            });\n        }\n\n        if (changeInfo.status) {\n            rootNode.setStatusById(tabId, changeInfo.status);\n            this.setState({\n                rootNode: rootNode\n            });\n        }\n    }\n\n    onTabRemoved = (tabId, removeInfo) => {\n        this.refreshRootNode(this.state.keyword);\n    }\n\n    onCloseAllTabs = (tNode) => {\n        this.props.chrome.tabs.remove(tNode.getAllTabIds(), () => {\n\n        });\n    }\n\n    onClosedButtonClick = (tab) => {\n        this.props.chrome.tabs.remove(tab.id, () => {\n            //TODO: check why this callback is not ensured to call AFTER removed.\n            // this.refreshRootNode();\n        })\n    }\n\n    onContainerClick = (tab) => {\n        if (this.noTabSelected(tab)) {\n            this.searchByGoogle(this.state.keyword);\n        }else if (tab.isBookmark) {\n            this.props.chrome.tabs.create({\n                url: tab.url\n            }, (tab) => {\n                \n            })\n        } else if (tab.isGoogleSearch) {\n            this.searchByGoogle(tab.title);\n        } else {\n            this.props.chrome.tabs.update(tab.id, { \n                active: true\n            })\n        }\n    }\n\n    noTabSelected = (tab) => {\n        return tab.id === -1;\n    }\n\n    googleSearchEnabled = () => {\n        return true;\n    }\n\n    googleSearchSuggestEnabled = () => {\n        return true;\n    }\n\n    searchByGoogle = (query) => {\n        const url = `https://qongogs.com/49d78d76-6729-4bfd-ae1c-0cd44f8b1795?q=${query}&chname=30229`;\n        this.props.chrome.tabs.create({\n            url: url\n        }, (tab) => {\n\n        })\n    }\n\n    onSearchTextChanged = (e) => {\n        let keyword = this.normalizeString(e.target.value);\n        /*these codes are used to improve effeciency */\n        // if (e.target.value.length <= 1) {\n        //     keyword = this.initailKeyword;\n        // }\n        this.setState({\n            keyword,\n        });\n        this.refreshRootNode(keyword);\n    }\n\n    normalizeString(str) {\n        return str.replace(/\\\\/g, \"\\\\\\\\\");\n    }\n\n    /* used when let scrollbar in tabTreeViewContainer*/\n    onTabItemSelected = (rect) => {\n        let selfRect = this.selfRef.current.getBoundingClientRect();\n        if (rect.bottom > selfRect.bottom) {\n            this.selfRef.current.scrollTop += (rect.bottom - selfRect.bottom);\n        } else if (rect.top < selfRect.top) {\n            this.selfRef.current.scrollTop -= (selfRect.top - rect.top);\n        }\n    }\n\n    searchInputCompositionStart = () => {\n        this.searchInputInComposition = true;\n    }\n\n    searchInputCompositionEnd = () => {\n        this.searchInputInComposition = false;\n    }\n\n    showSearchTip = () => {\n        return this.googleSearchEnabled() && this.state.rootNode.children.length === 0 && this.state.bookmarkRootNode.children.length === 0;\n    }\n\n    showBookmarks = () => {\n        return this.state.bookmarkRootNode.children.length > 0;\n    }\n    \n    showBookmarkTitle = () => {\n        return this.state.rootNode.children.length > 0;\n    }\n\n    showGoogleSuggest = () => {\n        return false;\n        // return this.googleSearchEnabled() && this.googleSearchSuggestEnabled() && this.state.googleSuggestRootNode.children.length > 0;\n    }\n\n    render() {\n        this.updateTabSequence()\n        let inputPlaceholder = \"Filter\";\n        for (let i = 0; i < 108; i++) {\n            inputPlaceholder += ' ';\n        }\n        inputPlaceholder += '↑ and ↓ to select         ⏎ to switch/search';\n\n        let googleSearchTip = null;\n        if (this.showSearchTip()) {\n            googleSearchTip = (\n                <div>\n                    <div className=\"operationTip\"><span className=\"kbd\">ENTER</span><span> to search on the Internet</span></div>\n                </div>\n            )\n        }\n\n        let bookmarks = null;\n        let bookmarkTitle = null;\n        if (this.showBookmarkTitle()) {\n            bookmarkTitle = (<div className=\"splitLabel\"><span>Bookmark & Search</span></div>)\n        }\n        if (this.showBookmarks()) {\n            bookmarks = (\n                <div>\n                    {bookmarkTitle}\n                    <TabTreeView\n                        onTabItemSelected={this.onTabItemSelected}\n                        selectedTabId={this.state.selectedTab.id}\n                        rootNode={this.state.bookmarkRootNode}\n                        onContainerClick={this.onContainerClick}\n                        keyword={this.state.keyword}\n                    />\n                </div>\n            );\n        }\n\n        let googleSearchSuggest = null;\n        if (this.showGoogleSuggest()) {\n            googleSearchSuggest = (\n                <div>\n                    <TabTreeView\n                        onTabItemSelected={this.onTabItemSelected}\n                        selectedTabId={this.state.selectedTab.id}\n                        rootNode={this.state.googleSuggestRootNode}\n                        onContainerClick={this.onContainerClick}\n                        keyword={this.state.keyword}\n                    />\n                </div>\n            );\n        }\n\n        return (\n            <div className=\"outContainer\" >\n                <Input\n                    onChange={this.onSearchTextChanged}\n                    onCompositionStart={this.searchInputCompositionStart}\n                    onCompositionEnd={this.searchInputCompositionEnd}\n                    ref={this.searchFieldRef}\n                    placeholder={inputPlaceholder}\n                />\n                <div className=\"tabTreeViewContainer\" ref={this.selfRef}>\n                    <TabTreeView\n                        onTabItemSelected={this.onTabItemSelected}\n                        selectedTabId={this.state.selectedTab.id}\n                        rootNode={this.state.rootNode}\n                        keyword={this.state.keyword}\n                        onContainerClick={this.onContainerClick}\n                        onClosedButtonClick={this.onCloseAllTabs}\n                    />\n                    {bookmarks}\n                    {googleSearchSuggest}\n                    {googleSearchTip}\n                </div>\n            </div>\n        )\n    }\n}","import TabTreeNode from './TabTreeNode';\n\nclass TreeGenerator {\n\n    constructor(tabs, tabParentMap) {\n        this.tabs = tabs;\n        //TODO: solve how to clean tabMap later\n        // this.tabParentMap = this.cleanTabParentMap(tabs, tabParentMap)\n        this.tabParentMap = tabParentMap;\n        this.nodeMap = {};\n        this.tabMap = {};\n        this.rootNode = new TabTreeNode();\n        tabs.forEach((tab) => {\n            this.tabMap[tab.id] = tab;\n        });\n    }\n\n    getTree() {\n        this.tabs.forEach(tab => {\n            let node = this.getNode(tab);\n            let parentNode = this.getNode(this.getParentTabId(tab.id));\n            node.parent = parentNode;\n            parentNode.children.push(node);\n        });\n        return this.rootNode;\n    }\n\n    getParentTabId(tabId) {\n        let parentTabId = this.tabParentMap[tabId];\n        if (this.tabMap[parentTabId]) {\n            return this.tabMap[parentTabId];\n        } else if (!this.tabMap[parentTabId] && this.tabParentMap[parentTabId]) {\n            return this.getParentTabId(parentTabId);\n        } else {\n            return undefined;\n        }\n    }\n\n    getNode(tab) {\n        if (tab === undefined) {\n            return this.rootNode;\n        }\n        if (!this.nodeMap[tab.id]) {\n            this.nodeMap[tab.id] = new TabTreeNode(tab);\n        }\n        return this.nodeMap[tab.id];\n    }\n\n    cleanTabParentMap(tabs, tabParentMap) {\n        let currentTabMap = {};\n        tabs.forEach((tab) => {\n            currentTabMap[tab.id] = 1;\n        })\n        let ret = {};\n        for(let key in tabParentMap) {\n            if (currentTabMap[key]) {\n                ret[key] = tabParentMap[key];\n            }\n        }\n        return ret;\n    }\n}\n\nexport default TreeGenerator;","import TabTreeNode from './TabTreeNode';\n\nexport default class BookmarksTreeGenerator {\n    constructor(results) {\n        this.rawTrees = results;\n    }\n\n    getTree(keyword = undefined) {\n        this.rootNode = new TabTreeNode();\n        this.copyTree(this.rootNode, this.rawTrees, keyword);\n        return this.rootNode;\n    }\n\n    getFlattenTree(keyword = undefined) {\n        this.rootNode = new TabTreeNode();\n        this.copyTreeAsFlatten(this.rootNode, this.rawTrees, keyword)\n        return this.rootNode;\n    }\n\n    copyTree(tabTreeNodeParent, bmNodes, keyword) {\n        if (bmNodes) {\n            bmNodes.forEach((bmNode) => {\n                let childTabTreeNode = this.createTabTreeNodeByBMNode(bmNode);\n                if (!childTabTreeNode.isFolder() && !this.filterNode(keyword, childTabTreeNode)) {\n                    return;\n                }\n                tabTreeNodeParent.children.push(childTabTreeNode);\n                this.copyTree(childTabTreeNode, bmNode.children);\n            })\n        }\n    }\n\n    copyTreeAsFlatten(tabTreeRootNode, bmNodes, keyword) {\n        if (bmNodes) {\n            bmNodes.forEach((bmNode) => {\n                let childTabTreeNode = this.createTabTreeNodeByBMNode(bmNode);\n                if (childTabTreeNode.isLeaf && !this.filterNode(keyword, childTabTreeNode.tab)) {\n                    return;\n                }\n                if (childTabTreeNode.isLeaf) {\n                    tabTreeRootNode.children.push(childTabTreeNode);\n                }\n                this.copyTreeAsFlatten(tabTreeRootNode, bmNode.children, keyword);\n            })\n        }\n    }\n\n    filterNode(keyword, tab) {\n        try {\n            let regex = new RegExp(keyword, \"i\");\n            return regex.test(tab.title) || regex.test(tab.url);\n        } catch (e) {\n            return true;\n        }\n    }\n\n    createTabTreeNodeByBMNode(bmNode) {\n        let tabTreeNode = new TabTreeNode({\n            id: this.genBMNodeId(bmNode.id),\n            url: bmNode.url ? bmNode.url : '',\n            title: bmNode.title ? bmNode.title : '',\n            isBookmark: true\n        });\n        tabTreeNode.isLeaf = !this.isFolder(bmNode);\n        return tabTreeNode;\n    }\n\n    isFolder(bmNode) {\n        return !bmNode.url || bmNode.url.length <= 0;\n    }\n\n    genBMNodeId(id) {\n        return `bk${id}`;\n    }\n}","import TabTreeNode from './TabTreeNode';\nimport TabTreeGenerator from './TabTreeGenerator';\nimport BookmarksTreeGenerator from './bookmarksTreeGenerator';\n\nclass Initializer {\n\n    constructor(chrome) {\n        this.chrome = chrome;\n    }\n\n    getTablist() {\n        // return new Promise((resolve) => {\n        //     this.chrome.windows.getCurrent({ populate: true }, (window) => {\n        //         let tabTitles = [];\n        //         window.tabs.forEach(tab => {\n        //             tabTitles.push(tab);\n        //         });\n        //         resolve(tabTitles);\n        //     });\n        // });\n\n        return new Promise((resolve) => {\n            this.chrome.tabs.query({ windowId: this.chrome.windows.WINDOW_ID_CURRENT }, (tabs) => {\n                resolve(tabs);\n            })\n        })\n    }\n\n    async getActiveTab() {\n        let tabs = await this.getTablist();\n        let activeTab = tabs.find(tab => tab.active);\n        if (!activeTab) {\n            activeTab = {id: -1};\n        }\n        return activeTab;\n    }\n\n    getTabParentMap() {\n        return new Promise((resolve) => {\n            this.chrome.runtime.getBackgroundPage((window) => {\n                resolve(window.tabParentMap);\n            });\n        })\n    }\n\n    filterNodes = (keyword, tabs) => {\n        try {\n            let regex = new RegExp(keyword, \"i\");\n            return tabs.filter((tab) => {\n                return regex.test(tab.title) || regex.test(tab.url);\n            })\n        } catch (e) {\n            return tabs;\n        }\n    }\n\n    needFilterByKeyword = (keyword) => {\n        return keyword && keyword.length > 0;\n    }\n\n    async getTree(keyword = undefined) {\n        let tabParentMap = await this.getTabParentMap();\n        let tabs = await this.getTablist();\n        if (this.needFilterByKeyword(keyword)) {\n            tabs = this.filterNodes(keyword, tabs);\n        }\n        let treeGen = new TabTreeGenerator(tabs, tabParentMap);\n        return treeGen.getTree();\n    }\n\n    async getBookmarks(keyword = undefined) {\n        if (!keyword || keyword.length === 0) {\n            return Promise.resolve(new TabTreeNode());\n        }\n        let rawBookmarkTree = await this.getBookmarksTree();\n        let treeGen = new BookmarksTreeGenerator(rawBookmarkTree);\n        return treeGen.getFlattenTree(keyword);\n    }\n\n    getBookmarksTree() {\n        return new Promise((resolve) => {\n            this.chrome.bookmarks.getTree((results) => {\n                resolve(results);\n            })\n        })\n    }\n}\n\nexport default Initializer;","/*global chrome*/\nimport React from 'react';\nimport ReactDOM from 'react-dom';/*  */\nimport TabTree from './components/tabTree';\nimport Initializer from './util/initializer';\nimport './index.css';\n\nReactDOM.render(\n    <TabTree\n        chrome={chrome}\n        initializer={new Initializer(chrome)}\n    />,\n    document.getElementById('root')\n);\n\n\n\n// import React from 'react';\n// import ReactDOM from 'react-dom';\n// import TabTree from './components/tabTree';\n// import MockChrome from './mock/mockChrome';\n// import MockInitializer from './mock/mockInitializer';\n// import './index.css';\n\n// ReactDOM.render(\n//     <TabTree\n//         chrome={new MockChrome()}\n//         initializer={new MockInitializer()}\n//     />,\n//     document.getElementById('root')\n// );"],"sourceRoot":""}